<script>
  // ==================== CALIBRATION FUNCTIONS ====================
  
  let currentCalibrationType = null;
  
  // Load calibration data when room selection changes
  async function loadRoomCalibrationData() {
    try {
      const roomSelect = document.getElementById('calibrationRoomSelect');
      const roomId = roomSelect.value;
      
      if (!roomId) {
        // Reset to default values if no room selected
        document.getElementById('electricSensorValue').textContent = '0 kWh';
        document.getElementById('electricActualValue').textContent = '0 kWh';
        document.getElementById('electricCalibrationFactor').textContent = '1';
        document.getElementById('electricCalibrationDate').textContent = 'Ch∆∞a hi·ªáu chu·∫©n';
        document.getElementById('waterSensorValue').textContent = '0 m¬≥';
        document.getElementById('waterActualValue').textContent = '0 m¬≥';
        document.getElementById('waterCalibrationFactor').textContent = '1';
        document.getElementById('waterCalibrationDate').textContent = 'Ch∆∞a hi·ªáu chu·∫©n';
        return;
      }
      
      // Fetch calibration data for the selected room
      const response = await fetch(`/api/room-calibration/${roomId}`);
      const result = await response.json();
      
      if (result.success) {
        const data = result.data.calibrationData;
        
        // Update electricity values
        document.getElementById('electricSensorValue').textContent = `${data.electricity.sensorValue} kWh`;
        document.getElementById('electricActualValue').textContent = `${data.electricity.actualValue} kWh`;
        document.getElementById('electricCalibrationFactor').textContent = data.electricity.calibrationFactor;
        document.getElementById('electricCalibrationDate').textContent = data.electricity.calibratedAt 
          ? new Date(data.electricity.calibratedAt).toLocaleDateString('vi-VN') 
          : 'Ch∆∞a hi·ªáu chu·∫©n';
        
        // Update water values  
        document.getElementById('waterSensorValue').textContent = `${data.water.sensorValue} m¬≥`;
        document.getElementById('waterActualValue').textContent = `${data.water.actualValue} m¬≥`;
        document.getElementById('waterCalibrationFactor').textContent = data.water.calibrationFactor;
        document.getElementById('waterCalibrationDate').textContent = data.water.calibratedAt 
          ? new Date(data.water.calibratedAt).toLocaleDateString('vi-VN') 
          : 'Ch∆∞a hi·ªáu chu·∫©n';
          
        // Store calibration and lastData for later use
        window.currentRoomCalibrationData = result.data;
      } else {
        console.error('Error loading room calibration data:', result.error);
      }
    } catch (error) {
      console.error('Error loading room calibration data:', error);
    }
  }
  
  // Open calibration modal
  function openCalibrationModal(type) {
    try {
      currentCalibrationType = type;
      
      // Check if there are any rooms available
      const roomSelect = document.getElementById('calibrationRoomSelect');
      if (!roomSelect.value) {
        alert(`Kh√¥ng c√≥ ph√≤ng n√†o c√≥ c·∫£m bi·∫øn ${type === 'electricity' ? 'ƒëi·ªán' : 'n∆∞·ªõc'}. Vui l√≤ng th√™m nodes v√†o ph√≤ng tr∆∞·ªõc.`);
        return;
      }
      
      // Ensure we have latest calibration data before opening modal
      if (!window.currentRoomCalibrationData) {
        console.log('üîÑ Loading room calibration data before opening modal...');
        loadRoomCalibrationData().then(() => {
          // Retry opening modal after data is loaded
          setTimeout(() => openCalibrationModal(type), 100);
        });
        return;
      }
      
      // Update modal title and units
      const modalTitle = document.getElementById('calibrationModalTitle');
      const sensorUnit = document.getElementById('sensorUnit');
      const actualUnit = document.getElementById('actualUnit');
      const currentRawSensorUnit = document.getElementById('currentRawSensorUnit');
      const currentRawSensorGroup = document.getElementById('currentRawSensorGroup');
      
      if (type === 'electricity') {
        modalTitle.textContent = 'Hi·ªáu chu·∫©n c·∫£m bi·∫øn ƒëi·ªán';
        sensorUnit.textContent = 'kWh';
        actualUnit.textContent = 'kWh';
        currentRawSensorUnit.textContent = 'kWh';
        // ·∫®n tr∆∞·ªùng gi√° tr·ªã th·ª±c t·∫ø cho ƒëi·ªán (c√≥ th·ªÉ b·ªè comment d√≤ng d∆∞·ªõi n·∫øu mu·ªën hi·ªÉn th·ªã cho c·∫£ ƒëi·ªán)
        currentRawSensorGroup.style.display = 'none';
      } else if (type === 'water') {
        modalTitle.textContent = 'Hi·ªáu chu·∫©n c·∫£m bi·∫øn n∆∞·ªõc';
        sensorUnit.textContent = 'm¬≥';
        actualUnit.textContent = 'm¬≥';
        currentRawSensorUnit.textContent = 'm¬≥';
        // Hi·ªÉn th·ªã tr∆∞·ªùng gi√° tr·ªã th·ª±c t·∫ø cho n∆∞·ªõc
        currentRawSensorGroup.style.display = 'block';
      }
      
      // Set calibration type
      document.getElementById('calibrationType').value = type;
      
      // Reset form
      document.getElementById('calibrationForm').reset();
      document.getElementById('calibrationType').value = type;
      document.getElementById('calibrationPreview').style.display = 'none';
      
      // Check if selected room has the required sensor type
      const selectedOption = roomSelect.options[roomSelect.selectedIndex];
      const hasElectricity = selectedOption.getAttribute('data-has-electricity') === 'true';
      const hasWater = selectedOption.getAttribute('data-has-water') === 'true';
      
      if ((type === 'electricity' && !hasElectricity) || (type === 'water' && !hasWater)) {
        alert(`Ph√≤ng ƒë√£ ch·ªçn kh√¥ng c√≥ c·∫£m bi·∫øn ${type === 'electricity' ? 'ƒëi·ªán' : 'n∆∞·ªõc'}. Vui l√≤ng ch·ªçn ph√≤ng kh√°c.`);
        return;
      }
      
      // T√≠nh to√°n v√† hi·ªÉn th·ªã gi√° tr·ªã c·∫£m bi·∫øn th·ª±c t·∫ø hi·ªán t·∫°i cho n∆∞·ªõc
      if (type === 'water' && window.currentRoomCalibrationData) {
        console.log('üîç Debug - currentRoomCalibrationData:', window.currentRoomCalibrationData);
        
        const waterLastData = window.currentRoomCalibrationData.lastData.water;
        const waterCalibration = window.currentRoomCalibrationData.calibrationData.water;
        
        console.log('üîç Debug - waterLastData:', waterLastData);
        console.log('üîç Debug - waterCalibration:', waterCalibration);
        
        if (waterLastData && waterLastData.water !== null && waterLastData.water !== undefined) {
          // T√≠nh gi√° tr·ªã th√¥ = lastData / h·ªá s·ªë c≈© (n·∫øu c√≥), n·∫øu kh√¥ng c√≥ h·ªá s·ªë th√¨ gi·ªØ nguy√™n
          const oldCalibrationFactor = waterCalibration.calibrationFactor || 1.0;
          const currentRawValue = waterLastData.water / oldCalibrationFactor;
          
          console.log(`üîç Debug - lastData.water: ${waterLastData.water}, oldCalibrationFactor: ${oldCalibrationFactor}, currentRawValue: ${currentRawValue}`);
          
          document.getElementById('currentRawSensorValue').value = currentRawValue.toFixed(3);
          
          // Pre-fill gi√° tr·ªã hi·ªÉn th·ªã hi·ªán t·∫°i (lastData ƒë√£ qua hi·ªáu ch·ªânh)
          document.getElementById('sensorValue').value = waterLastData.water.toFixed(3);
          
          // ·∫®n alert warning
          document.getElementById('waterNoDataAlert').style.display = 'none';
        } else {
          console.log('‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu lastData.water ho·∫∑c gi√° tr·ªã = 0');
          // Hi·ªÉn th·ªã th√¥ng b√°o cho ng∆∞·ªùi d√πng
          document.getElementById('currentRawSensorValue').value = '';
          document.getElementById('currentRawSensorValue').placeholder = 'Ch∆∞a c√≥ d·ªØ li·ªáu c·∫£m bi·∫øn';
          
          // Hi·ªÉn th·ªã alert warning
          document.getElementById('waterNoDataAlert').style.display = 'block';
        }
      }
      
      // ·∫®n waterNoDataAlert cho ƒëi·ªán
      if (type === 'electricity') {
        document.getElementById('waterNoDataAlert').style.display = 'none';
      }
      
      // Load current calibration data from UI for electricity (gi·ªØ nguy√™n logic c≈©)
      if (type === 'electricity') {
        const prefix = 'electric';
        const currentSensorValueText = document.getElementById(`${prefix}SensorValue`).textContent;
        const currentActualValueText = document.getElementById(`${prefix}ActualValue`).textContent;
        
        // Extract numeric values (remove unit text)
        const currentSensorValue = parseFloat(currentSensorValueText.replace(/[^\d.]/g, ''));
        const currentActualValue = parseFloat(currentActualValueText.replace(/[^\d.]/g, ''));
        
        // Pre-fill form if we have existing data
        if (currentSensorValue > 0) {
          document.getElementById('sensorValue').value = currentSensorValue;
        }
        if (currentActualValue > 0) {
          document.getElementById('actualValue').value = currentActualValue;
        }
        
        // Update preview if both values exist
        if (currentSensorValue > 0 && currentActualValue > 0) {
          updateCalibrationPreview();
        }
      }
      
      // Show modal
      new bootstrap.Modal(document.getElementById('calibrationModal')).show();
      
    } catch (error) {
      console.error('Error opening calibration modal:', error);
      if (typeof toastManager !== 'undefined') {
        toastManager.error('L·ªói khi m·ªü modal hi·ªáu chu·∫©n: ' + error.message);
      } else {
        alert('L·ªói khi m·ªü modal hi·ªáu chu·∫©n: ' + error.message);
      }
    }
  }
  
  // Calculate and preview calibration
  function updateCalibrationPreview() {
    try {
      const type = document.getElementById('calibrationType').value;
      const sensorValue = parseFloat(document.getElementById('sensorValue').value);
      const actualValue = parseFloat(document.getElementById('actualValue').value);
      
      let calibrationFactor = 0;
      let formula = '';
      
      if (type === 'water') {
        // Cho n∆∞·ªõc: ki·ªÉm tra xem c√≥ gi√° tr·ªã th√¥ hay kh√¥ng
        const currentRawSensorValue = parseFloat(document.getElementById('currentRawSensorValue').value);
        
        if (currentRawSensorValue && currentRawSensorValue > 0 && actualValue > 0) {
          // C√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng gi√° tr·ªã th√¥
          calibrationFactor = actualValue / currentRawSensorValue;
          formula = 'Gi√° tr·ªã th·ª±c = C·∫£m bi·∫øn th√¥ √ó H·ªá s·ªë';
        } else if (sensorValue > 0 && actualValue > 0) {
          // Ch∆∞a c√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng sensorValue nh∆∞ ƒëi·ªán
          calibrationFactor = actualValue / sensorValue;
          formula = 'Gi√° tr·ªã th·ª±c = C·∫£m bi·∫øn hi·ªÉn th·ªã √ó H·ªá s·ªë';
        }
      } else {
        // Cho ƒëi·ªán: gi·ªØ nguy√™n logic c≈©
        if (sensorValue > 0 && actualValue > 0) {
          calibrationFactor = actualValue / sensorValue;
          formula = 'Gi√° tr·ªã th·ª±c = C·∫£m bi·∫øn √ó H·ªá s·ªë';
        }
      }
      
      if (calibrationFactor > 0) {
        document.getElementById('previewCalibrationFactor').textContent = calibrationFactor.toFixed(4);
        document.getElementById('previewFormula').textContent = formula;
        document.getElementById('calibrationPreview').style.display = 'block';
      } else {
        document.getElementById('calibrationPreview').style.display = 'none';
      }
    } catch (error) {
      document.getElementById('calibrationPreview').style.display = 'none';
    }
  }
  
  // Submit calibration
  async function submitCalibration() {
    try {
      const form = document.getElementById('calibrationForm');
      const formData = new FormData(form);
      
      const sensorValue = parseFloat(formData.get('sensorValue'));
      const actualValue = parseFloat(formData.get('actualValue'));
      const type = formData.get('type');
      
      // Get roomId from the external dropdown
      const roomSelect = document.getElementById('calibrationRoomSelect');
      const roomId = roomSelect.value;
      
      // Validation
      if (!roomId) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn');
        return;
      }
      
      if (!sensorValue || sensorValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã c·∫£m bi·∫øn h·ª£p l·ªá');
        return;
      }
      
      if (!actualValue || actualValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã th·ª±c t·∫ø h·ª£p l·ªá');
        return;
      }
      
      // Cho n∆∞·ªõc, c·∫ßn ki·ªÉm tra th√™m currentRawSensorValue
      let calibrationData = {
        type,
        roomId,
        sensorValue,
        actualValue
      };
      
      if (type === 'water') {
        const currentRawSensorValue = parseFloat(formData.get('currentRawSensorValue'));
        if (currentRawSensorValue && currentRawSensorValue > 0) {
          // C√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng gi√° tr·ªã th√¥
          calibrationData.currentRawSensorValue = currentRawSensorValue;
          console.log('üíß S·ª≠ d·ª•ng gi√° tr·ªã c·∫£m bi·∫øn th√¥:', currentRawSensorValue);
        } else {
          // Ch∆∞a c√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng sensorValue nh∆∞ ƒëi·ªán
          console.log('üíß Ch∆∞a c√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng sensorValue nh∆∞ ƒëi·ªán');
          calibrationData.useDisplayValue = true; // Flag ƒë·ªÉ controller bi·∫øt c√°ch t√≠nh
        }
      }
      
      // Disable submit button
      const submitBtn = document.querySelector('#calibrationModal .btn-settings');
      const originalText = submitBtn.innerHTML;
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêang l∆∞u...';

      // Send request
      const response = await fetch('/api/update-calibration', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(calibrationData)
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error);
      }

      // Update UI
      updateCalibrationUI(type, result.data);

      // Show success message
      if (typeof toastManager !== 'undefined') {
        toastManager.success(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu chu·∫©n ${type === 'electricity' ? 'ƒëi·ªán' : 'n∆∞·ªõc'} cho ph√≤ng ${roomId}`);
      } else {
        alert(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu chu·∫©n ${type === 'electricity' ? 'ƒëi·ªán' : 'n∆∞·ªõc'} cho ph√≤ng ${roomId}`);
      }

      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('calibrationModal'));
      modal.hide();

      // Reset button
      submitBtn.disabled = false;
      submitBtn.innerHTML = originalText;

    } catch (error) {
      console.error('Error submitting calibration:', error);

      // Reset button
      const submitBtn = document.querySelector('#calibrationModal .btn-settings');
      submitBtn.disabled = false;
      submitBtn.innerHTML = '<i class="fas fa-save"></i> L∆∞u hi·ªáu chu·∫©n';
      
      alert('L·ªói khi l∆∞u hi·ªáu chu·∫©n: ' + error.message);
    }
  }
  
  // Update calibration UI
  function updateCalibrationUI(type, data) {
    const prefix = type === 'electricity' ? 'electric' : 'water';
    const unit = type === 'electricity' ? 'kWh' : 'm¬≥';
    
    document.getElementById(`${prefix}SensorValue`).textContent = `${data.sensorValue} ${unit}`;
    document.getElementById(`${prefix}ActualValue`).textContent = `${data.actualValue} ${unit}`;
    document.getElementById(`${prefix}CalibrationFactor`).textContent = data.calibrationFactor;
    document.getElementById(`${prefix}CalibrationDate`).textContent = new Date().toLocaleDateString('vi-VN');
  }

  // Add event listeners for real-time preview updates
  document.addEventListener('DOMContentLoaded', function() {
    // Add event listeners to form inputs
    const sensorValueInput = document.getElementById('sensorValue');
    const actualValueInput = document.getElementById('actualValue');
    
    if (sensorValueInput) {
      sensorValueInput.addEventListener('input', updateCalibrationPreview);
    }
    if (actualValueInput) {
      actualValueInput.addEventListener('input', updateCalibrationPreview);
    }
  });
</script> 