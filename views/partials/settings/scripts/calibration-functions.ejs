<script>
  // ==================== CALIBRATION FUNCTIONS ====================
  
  let currentElectricCalibrationData = null; // L∆∞u tr·ªØ d·ªØ li·ªáu hi·ªáu chu·∫©n ƒëi·ªán hi·ªán t·∫°i
  
  // Load calibration data when room selection changes
  async function loadRoomCalibrationData() {
    try {
      const roomSelect = document.getElementById('calibrationRoomSelect');
      const roomId = roomSelect.value;
      
      if (!roomId) {
        // Reset to default values if no room selected
        document.getElementById('electricSensorValue').textContent = '0 kWh';
        document.getElementById('electricActualValue').textContent = '0 kWh';
        document.getElementById('electricOffset').textContent = '0';
        document.getElementById('electricCalibrationFactor').textContent = '1';
        document.getElementById('electricCalibrationDate').textContent = 'Ch∆∞a hi·ªáu chu·∫©n';
        document.getElementById('waterSensorValue').textContent = '0 m¬≥';
        document.getElementById('waterActualValue').textContent = '0 m¬≥';
        document.getElementById('waterCalibrationFactor').textContent = '1';
        document.getElementById('waterCalibrationDate').textContent = 'Ch∆∞a hi·ªáu chu·∫©n';
        return;
      }
      
      // Fetch calibration data for the selected room
      const response = await fetch(`/api/room-calibration/${roomId}`);
      const result = await response.json();
      
      if (result.success) {
        const data = result.data.calibrationData;
        
        // Update electricity values
        document.getElementById('electricSensorValue').textContent = `${data.electricity.sensorValue || 0} kWh`;
        document.getElementById('electricActualValue').textContent = `${data.electricity.actualValue || 0} kWh`;
        document.getElementById('electricOffset').textContent = data.electricity.offset || 0;
        document.getElementById('electricCalibrationFactor').textContent = data.electricity.calibrationFactor || 1;
        document.getElementById('electricCalibrationDate').textContent = data.electricity.calibratedAt 
          ? new Date(data.electricity.calibratedAt).toLocaleDateString('vi-VN') 
          : 'Ch∆∞a hi·ªáu chu·∫©n';
        
        // Update water values  
        document.getElementById('waterSensorValue').textContent = `${data.water.sensorValue || 0} m¬≥`;
        document.getElementById('waterActualValue').textContent = `${data.water.actualValue || 0} m¬≥`;
        document.getElementById('waterCalibrationFactor').textContent = data.water.calibrationFactor || 1;
        document.getElementById('waterCalibrationDate').textContent = data.water.calibratedAt 
          ? new Date(data.water.calibratedAt).toLocaleDateString('vi-VN') 
          : 'Ch∆∞a hi·ªáu chu·∫©n';
          
        // Store calibration and lastData for later use
        window.currentRoomCalibrationData = result.data;
        currentElectricCalibrationData = data.electricity;
      } else {
        console.error('Error loading room calibration data:', result.error);
      }
    } catch (error) {
      console.error('Error loading room calibration data:', error);
    }
  }

  // ==================== ELECTRIC INITIAL CALIBRATION ====================
  
  // Open electric initial calibration modal
  function openElectricInitialCalibrationModal() {
    try {
      // Check if there are any rooms available
      const roomSelect = document.getElementById('calibrationRoomSelect');
      if (!roomSelect.value) {
        alert('Kh√¥ng c√≥ ph√≤ng n√†o c√≥ c·∫£m bi·∫øn ƒëi·ªán. Vui l√≤ng th√™m nodes v√†o ph√≤ng tr∆∞·ªõc.');
        return;
      }

      // Reset form
      document.getElementById('electricInitialSensorValue').value = '';
      document.getElementById('electricInitialMeterValue').value = '';
      document.getElementById('electricInitialPreview').style.display = 'none';
      
      // Show modal
      new bootstrap.Modal(document.getElementById('electricInitialCalibrationModal')).show();
      
    } catch (error) {
      console.error('Error opening electric initial calibration modal:', error);
      if (typeof toastManager !== 'undefined') {
        toastManager.error('L·ªói khi m·ªü modal hi·ªáu chu·∫©n ban ƒë·∫ßu: ' + error.message);
      } else {
        alert('L·ªói khi m·ªü modal hi·ªáu chu·∫©n ban ƒë·∫ßu: ' + error.message);
      }
    }
  }
  
  // Calculate and preview electric initial calibration
  function updateElectricInitialPreview() {
    try {
      const sensorValue = parseFloat(document.getElementById('electricInitialSensorValue').value);
      const meterValue = parseFloat(document.getElementById('electricInitialMeterValue').value);
      
      if (sensorValue > 0 && meterValue > 0) {
        const offset = meterValue - sensorValue;
        
        document.getElementById('electricInitialOffsetPreview').textContent = offset.toFixed(4);
        document.getElementById('electricInitialPreview').style.display = 'block';
      } else {
        document.getElementById('electricInitialPreview').style.display = 'none';
      }
    } catch (error) {
      document.getElementById('electricInitialPreview').style.display = 'none';
    }
  }
  
  // Submit electric initial calibration
  async function submitElectricInitialCalibration() {
    try {
      const sensorValue = parseFloat(document.getElementById('electricInitialSensorValue').value);
      const meterValue = parseFloat(document.getElementById('electricInitialMeterValue').value);
      const roomId = document.getElementById('calibrationRoomSelect').value;
      
      // Validation
      if (!roomId) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn');
        return;
      }
      
      if (!sensorValue || sensorValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã c·∫£m bi·∫øn h·ª£p l·ªá');
        return;
      }
      
      if (!meterValue || meterValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã ƒë·ªìng h·ªì h·ª£p l·ªá');
        return;
      }
      
      // Disable submit button
      const submitBtn = event.target;
      const originalText = submitBtn.innerHTML;
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêang l∆∞u...';
      
      // Calculate offset
      const offset = meterValue - sensorValue;
      
      // Prepare data
      const calibrationData = {
        type: 'electricity',
        roomId,
        isInitialCalibration: true,
        offset: offset,
        calibrationFactor: 1,
        firstSensorValue: sensorValue,
        firstActualValue: meterValue
      };
      
      console.log('üì§ Sending electric initial calibration data:', JSON.stringify(calibrationData, null, 2));
      
      // Send request
      const response = await fetch('/api/update-calibration', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(calibrationData)
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error);
      }

      // Update UI
      updateElectricCalibrationUI(result.data);

      // Show success message
      if (typeof toastManager !== 'undefined') {
        toastManager.success(`ƒê√£ thi·∫øt l·∫≠p hi·ªáu chu·∫©n ban ƒë·∫ßu ƒëi·ªán cho ph√≤ng ${roomId}`);
      } else {
        alert(`ƒê√£ thi·∫øt l·∫≠p hi·ªáu chu·∫©n ban ƒë·∫ßu ƒëi·ªán cho ph√≤ng ${roomId}`);
      }

      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('electricInitialCalibrationModal'));
      modal.hide();

      // Reload calibration data
      await loadRoomCalibrationData();

      // Reset button
      submitBtn.disabled = false;
      submitBtn.innerHTML = originalText;

    } catch (error) {
      console.error('Error submitting electric initial calibration:', error);

      // Reset button
      const submitBtn = event.target;
      submitBtn.disabled = false;
      submitBtn.innerHTML = '<i class="fas fa-save"></i> L∆∞u hi·ªáu chu·∫©n ban ƒë·∫ßu';
      
      alert('L·ªói khi l∆∞u hi·ªáu chu·∫©n ban ƒë·∫ßu: ' + error.message);
    }
  }

  // ==================== ELECTRIC ERROR CORRECTION ====================
  
  // Open electric error correction modal
  function openElectricErrorCorrectionModal() {
    try {
      // Check if there are any rooms available
      const roomSelect = document.getElementById('calibrationRoomSelect');
      if (!roomSelect.value) {
        alert('Kh√¥ng c√≥ ph√≤ng n√†o c√≥ c·∫£m bi·∫øn ƒëi·ªán. Vui l√≤ng th√™m nodes v√†o ph√≤ng tr∆∞·ªõc.');
        return;
      }

      // Check if there's initial calibration data
      if (!currentElectricCalibrationData || 
          currentElectricCalibrationData.firstSensorValue === undefined || 
          currentElectricCalibrationData.firstActualValue === undefined) {
        alert('Ch∆∞a c√≥ d·ªØ li·ªáu hi·ªáu chu·∫©n ban ƒë·∫ßu. Vui l√≤ng th·ª±c hi·ªán hi·ªáu chu·∫©n ban ƒë·∫ßu tr∆∞·ªõc.');
        return;
      }

      // Display existing calibration data
      document.getElementById('electricErrorFirstSensorValue').textContent = `${currentElectricCalibrationData.firstSensorValue} kWh`;
      document.getElementById('electricErrorFirstActualValue').textContent = `${currentElectricCalibrationData.firstActualValue} kWh`;
      document.getElementById('electricErrorCurrentOffset').textContent = currentElectricCalibrationData.offset || '0';
      document.getElementById('electricErrorCurrentCalibrationFactor').textContent = currentElectricCalibrationData.calibrationFactor || '1';

      // Reset form
      document.getElementById('electricErrorCurrentSensorValue').value = '';
      document.getElementById('electricErrorCurrentMeterValue').value = '';
      document.getElementById('electricErrorPreview').style.display = 'none';
      
      // Show modal
      new bootstrap.Modal(document.getElementById('electricErrorCorrectionModal')).show();
      
    } catch (error) {
      console.error('Error opening electric error correction modal:', error);
      if (typeof toastManager !== 'undefined') {
        toastManager.error('L·ªói khi m·ªü modal hi·ªáu chu·∫©n sai s·ªë: ' + error.message);
      } else {
        alert('L·ªói khi m·ªü modal hi·ªáu chu·∫©n sai s·ªë: ' + error.message);
      }
    }
  }
  
  // Calculate and preview electric error correction
  function updateElectricErrorPreview() {
    try {
      const currentSensorValue = parseFloat(document.getElementById('electricErrorCurrentSensorValue').value);
      const currentMeterValue = parseFloat(document.getElementById('electricErrorCurrentMeterValue').value);
      
      if (!currentElectricCalibrationData || !currentSensorValue || !currentMeterValue) {
        document.getElementById('electricErrorPreview').style.display = 'none';
        return;
      }
      
      const firstSensorValue = currentElectricCalibrationData.firstSensorValue;
      const firstActualValue = currentElectricCalibrationData.firstActualValue;
      
      if (currentSensorValue > 0 && currentMeterValue > 0 && firstSensorValue && firstActualValue) {
        // Calculate new calibration factor
        const newCalibrationFactor = (currentMeterValue - firstActualValue) / (currentSensorValue - firstSensorValue);
        
        // Calculate new offset
        const newOffset = firstActualValue - (firstSensorValue * newCalibrationFactor);
        
        // Update preview
        document.getElementById('electricErrorNewCalibrationFactor').textContent = newCalibrationFactor.toFixed(4);
        document.getElementById('electricErrorNewOffset').textContent = newOffset.toFixed(4);
        document.getElementById('electricErrorCalibrationFormula').textContent = 
          `(${currentMeterValue} - ${firstActualValue}) / (${currentSensorValue} - ${firstSensorValue})`;
        document.getElementById('electricErrorOffsetFormula').textContent = 
          `${firstActualValue} - (${firstSensorValue} √ó ${newCalibrationFactor.toFixed(4)})`;
        
        document.getElementById('electricErrorPreview').style.display = 'block';
      } else {
        document.getElementById('electricErrorPreview').style.display = 'none';
      }
    } catch (error) {
      document.getElementById('electricErrorPreview').style.display = 'none';
    }
  }
  
  // Submit electric error correction
  async function submitElectricErrorCorrection() {
    try {
      const currentSensorValue = parseFloat(document.getElementById('electricErrorCurrentSensorValue').value);
      const currentMeterValue = parseFloat(document.getElementById('electricErrorCurrentMeterValue').value);
      const roomId = document.getElementById('calibrationRoomSelect').value;
      
      // Validation
      if (!roomId) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn');
        return;
      }
      
      if (!currentSensorValue || currentSensorValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã c·∫£m bi·∫øn hi·ªán t·∫°i h·ª£p l·ªá');
        return;
      }
      
      if (!currentMeterValue || currentMeterValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã ƒë·ªìng h·ªì hi·ªán t·∫°i h·ª£p l·ªá');
        return;
      }
      
      if (!currentElectricCalibrationData) {
        alert('Kh√¥ng c√≥ d·ªØ li·ªáu hi·ªáu chu·∫©n ban ƒë·∫ßu');
        return;
      }
      
      // Disable submit button
      const submitBtn = event.target;
      const originalText = submitBtn.innerHTML;
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêang l∆∞u...';
      
      const firstSensorValue = currentElectricCalibrationData.firstSensorValue;
      const firstActualValue = currentElectricCalibrationData.firstActualValue;
      
      // Calculate new calibration factor and offset
      const newCalibrationFactor = (currentMeterValue - firstActualValue) / (currentSensorValue - firstSensorValue);
      const newOffset = firstActualValue - (firstSensorValue * newCalibrationFactor);
      
      // Prepare data
      const calibrationData = {
        type: 'electricity',
        roomId,
        isErrorCorrection: true,
        offset: newOffset,
        calibrationFactor: newCalibrationFactor,
        firstSensorValue: firstSensorValue,
        firstActualValue: firstActualValue,
        currentSensorValue: currentSensorValue,
        currentMeterValue: currentMeterValue
      };
      
      console.log('üì§ Sending electric error correction data:', JSON.stringify(calibrationData, null, 2));
      
      // Send request
      const response = await fetch('/api/update-calibration', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(calibrationData)
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error);
      }

      // Update UI
      updateElectricCalibrationUI(result.data);

      // Show success message
      if (typeof toastManager !== 'undefined') {
        toastManager.success(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu ch·ªânh sai s·ªë ƒëi·ªán cho ph√≤ng ${roomId}`);
      } else {
        alert(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu ch·ªânh sai s·ªë ƒëi·ªán cho ph√≤ng ${roomId}`);
      }

      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('electricErrorCorrectionModal'));
      modal.hide();

      // Reload calibration data
      await loadRoomCalibrationData();

      // Reset button
      submitBtn.disabled = false;
      submitBtn.innerHTML = originalText;

    } catch (error) {
      console.error('Error submitting electric error correction:', error);

      // Reset button
      const submitBtn = event.target;
      submitBtn.disabled = false;
      submitBtn.innerHTML = '<i class="fas fa-save"></i> L∆∞u hi·ªáu chu·∫©n sai s·ªë';
      
      alert('L·ªói khi l∆∞u hi·ªáu ch·ªânh sai s·ªë: ' + error.message);
    }
  }

  // ==================== WATER CALIBRATION (OLD LOGIC) ====================
  
  // Open water calibration modal (keep old logic)
  function openCalibrationModal(type) {
    if (type !== 'water') return; // Only handle water here
    
    try {
      // Check if there are any rooms available
      const roomSelect = document.getElementById('calibrationRoomSelect');
      if (!roomSelect.value) {
        alert('Kh√¥ng c√≥ ph√≤ng n√†o c√≥ c·∫£m bi·∫øn n∆∞·ªõc. Vui l√≤ng th√™m nodes v√†o ph√≤ng tr∆∞·ªõc.');
        return;
      }
      
      // Reset form
      document.getElementById('waterSensorValue').value = '';
      document.getElementById('waterActualValue').value = '';
      document.getElementById('waterCalibrationPreview').style.display = 'none';
      
      // Handle water-specific logic (keep old behavior)
      if (window.currentRoomCalibrationData) {
        const waterLastData = window.currentRoomCalibrationData.lastData.water;
        const waterCalibration = window.currentRoomCalibrationData.calibrationData.water;
        
        if (waterLastData && waterLastData.water !== null && waterLastData.water !== undefined) {
          // T√≠nh gi√° tr·ªã th√¥ = lastData / h·ªá s·ªë c≈© (n·∫øu c√≥), n·∫øu kh√¥ng c√≥ h·ªá s·ªë th√¨ gi·ªØ nguy√™n
          const oldCalibrationFactor = waterCalibration.calibrationFactor || 1.0;
          const currentRawValue = waterLastData.water / oldCalibrationFactor;
          
          document.getElementById('currentRawSensorValue').value = currentRawValue.toFixed(3);
          document.getElementById('waterSensorValue').value = waterLastData.water.toFixed(3);
          document.getElementById('currentRawSensorGroup').style.display = 'block';
          document.getElementById('waterNoDataAlert').style.display = 'none';
        } else {
          document.getElementById('currentRawSensorValue').value = '';
          document.getElementById('currentRawSensorValue').placeholder = 'Ch∆∞a c√≥ d·ªØ li·ªáu c·∫£m bi·∫øn';
          document.getElementById('currentRawSensorGroup').style.display = 'block';
          document.getElementById('waterNoDataAlert').style.display = 'block';
        }
      }
      
      // Show modal
      new bootstrap.Modal(document.getElementById('waterCalibrationModal')).show();
      
    } catch (error) {
      console.error('Error opening water calibration modal:', error);
      if (typeof toastManager !== 'undefined') {
        toastManager.error('L·ªói khi m·ªü modal hi·ªáu chu·∫©n n∆∞·ªõc: ' + error.message);
      } else {
        alert('L·ªói khi m·ªü modal hi·ªáu chu·∫©n n∆∞·ªõc: ' + error.message);
      }
    }
  }
  
  // Calculate and preview water calibration
  function updateWaterCalibrationPreview() {
    try {
      const sensorValue = parseFloat(document.getElementById('waterSensorValue').value);
      const actualValue = parseFloat(document.getElementById('waterActualValue').value);
      
      let calibrationFactor = 0;
      let formula = '';
      
      // Cho n∆∞·ªõc: ki·ªÉm tra xem c√≥ gi√° tr·ªã th√¥ hay kh√¥ng
      const currentRawSensorValue = parseFloat(document.getElementById('currentRawSensorValue').value);
      
      if (currentRawSensorValue && currentRawSensorValue > 0 && actualValue > 0) {
        // C√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng gi√° tr·ªã th√¥
        calibrationFactor = actualValue / currentRawSensorValue;
        formula = 'Gi√° tr·ªã th·ª±c = C·∫£m bi·∫øn th√¥ √ó H·ªá s·ªë';
      } else if (sensorValue > 0 && actualValue > 0) {
        // Ch∆∞a c√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng sensorValue
        calibrationFactor = actualValue / sensorValue;
        formula = 'Gi√° tr·ªã th·ª±c = C·∫£m bi·∫øn hi·ªÉn th·ªã √ó H·ªá s·ªë';
      }
      
      if (calibrationFactor > 0) {
        document.getElementById('waterPreviewCalibrationFactor').textContent = calibrationFactor.toFixed(4);
        document.getElementById('waterPreviewFormula').textContent = formula;
        document.getElementById('waterCalibrationPreview').style.display = 'block';
      } else {
        document.getElementById('waterCalibrationPreview').style.display = 'none';
      }
    } catch (error) {
      document.getElementById('waterCalibrationPreview').style.display = 'none';
    }
  }
  
  // Submit water calibration (old logic)
  async function submitWaterCalibration() {
    try {
      const sensorValue = parseFloat(document.getElementById('waterSensorValue').value);
      const actualValue = parseFloat(document.getElementById('waterActualValue').value);
      const roomId = document.getElementById('calibrationRoomSelect').value;
      
      // Validation
      if (!roomId) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn');
        return;
      }
      
      if (!sensorValue || sensorValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã c·∫£m bi·∫øn h·ª£p l·ªá');
        return;
      }
      
      if (!actualValue || actualValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã th·ª±c t·∫ø h·ª£p l·ªá');
        return;
      }
      
      // Disable submit button
      const submitBtn = event.target;
      const originalText = submitBtn.innerHTML;
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêang l∆∞u...';

      // Prepare old-style data for water
      let calibrationData = {
        type: 'water',
        roomId,
        sensorValue,
        actualValue
      };
      
      // Cho n∆∞·ªõc, c·∫ßn ki·ªÉm tra th√™m currentRawSensorValue
      const currentRawSensorValue = parseFloat(document.getElementById('currentRawSensorValue').value);
      if (currentRawSensorValue && currentRawSensorValue > 0) {
        // C√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng gi√° tr·ªã th√¥
        calibrationData.currentRawSensorValue = currentRawSensorValue;
      } else {
        // Ch∆∞a c√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng sensorValue
        calibrationData.useDisplayValue = true;
      }

      console.log('üì§ Sending water calibration data:', JSON.stringify(calibrationData, null, 2));

      // Send request to old endpoint (you'll need to add this back for water)
      const response = await fetch('/api/update-calibration-water', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(calibrationData)
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error);
      }

      // Update UI
      updateWaterCalibrationUI(result.data);

      // Show success message
      if (typeof toastManager !== 'undefined') {
        toastManager.success(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu chu·∫©n n∆∞·ªõc cho ph√≤ng ${roomId}`);
      } else {
        alert(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu chu·∫©n n∆∞·ªõc cho ph√≤ng ${roomId}`);
      }

      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('waterCalibrationModal'));
      modal.hide();

      // Reload calibration data
      await loadRoomCalibrationData();

      // Reset button
      submitBtn.disabled = false;
      submitBtn.innerHTML = originalText;

    } catch (error) {
      console.error('Error submitting water calibration:', error);

      // Reset button
      const submitBtn = event.target;
      submitBtn.disabled = false;
      submitBtn.innerHTML = '<i class="fas fa-save"></i> L∆∞u hi·ªáu chu·∫©n';
      
      alert('L·ªói khi l∆∞u hi·ªáu chu·∫©n n∆∞·ªõc: ' + error.message);
    }
  }

  // ==================== UI UPDATE FUNCTIONS ====================
  
  // Update electric calibration UI
  function updateElectricCalibrationUI(data) {
    document.getElementById('electricSensorValue').textContent = `${data.firstSensorValue || 0} kWh`;
    document.getElementById('electricActualValue').textContent = `${data.firstActualValue || 0} kWh`;
    document.getElementById('electricOffset').textContent = data.offset || 0;
    document.getElementById('electricCalibrationFactor').textContent = data.calibrationFactor || 1;
    document.getElementById('electricCalibrationDate').textContent = new Date().toLocaleDateString('vi-VN');
  }

  // Update water calibration UI (old style)
  function updateWaterCalibrationUI(data) {
    document.getElementById('waterSensorValue').textContent = `${data.sensorValue || 0} m¬≥`;
    document.getElementById('waterActualValue').textContent = `${data.actualValue || 0} m¬≥`;
    document.getElementById('waterCalibrationFactor').textContent = data.calibrationFactor || 1;
    document.getElementById('waterCalibrationDate').textContent = new Date().toLocaleDateString('vi-VN');
  }

  // ==================== EVENT LISTENERS ====================
  
  // Add event listeners for real-time preview updates
  document.addEventListener('DOMContentLoaded', function() {
    // Electric initial calibration inputs
    const electricInitialSensorInput = document.getElementById('electricInitialSensorValue');
    const electricInitialMeterInput = document.getElementById('electricInitialMeterValue');
    
    if (electricInitialSensorInput) {
      electricInitialSensorInput.addEventListener('input', updateElectricInitialPreview);
    }
    if (electricInitialMeterInput) {
      electricInitialMeterInput.addEventListener('input', updateElectricInitialPreview);
    }
    
    // Electric error correction inputs
    const electricErrorSensorInput = document.getElementById('electricErrorCurrentSensorValue');
    const electricErrorMeterInput = document.getElementById('electricErrorCurrentMeterValue');
    
    if (electricErrorSensorInput) {
      electricErrorSensorInput.addEventListener('input', updateElectricErrorPreview);
    }
    if (electricErrorMeterInput) {
      electricErrorMeterInput.addEventListener('input', updateElectricErrorPreview);
    }
    
    // Water calibration inputs
    const waterSensorInput = document.getElementById('waterSensorValue');
    const waterActualInput = document.getElementById('waterActualValue');
    
    if (waterSensorInput) {
      waterSensorInput.addEventListener('input', updateWaterCalibrationPreview);
    }
    if (waterActualInput) {
      waterActualInput.addEventListener('input', updateWaterCalibrationPreview);
    }
  });
</script> 