<script>
  // ==================== CALIBRATION FUNCTIONS ====================
  
  let currentElectricCalibrationData = null; // L∆∞u tr·ªØ d·ªØ li·ªáu hi·ªáu chu·∫©n ƒëi·ªán hi·ªán t·∫°i
  
  // Load calibration data when room selection changes
  async function loadRoomCalibrationData() {
    try {
      const roomSelect = document.getElementById('calibrationRoomSelect');
      const roomId = roomSelect.value;
      
      if (!roomId) {
        // Reset to default values if no room selected
        document.getElementById('electricSensorValue').textContent = '0 kWh';
        document.getElementById('electricActualValue').textContent = '0 kWh';
        document.getElementById('electricOffset').textContent = '0';
        document.getElementById('electricCalibrationFactor').textContent = '1';
        document.getElementById('electricCalibrationDate').textContent = 'Ch∆∞a hi·ªáu chu·∫©n';
        document.getElementById('waterSensorValue').textContent = '0 m¬≥';
        document.getElementById('waterActualValue').textContent = '0 m¬≥';
        document.getElementById('waterCalibrationFactor').textContent = '1';
        document.getElementById('waterCalibrationDate').textContent = 'Ch∆∞a hi·ªáu chu·∫©n';
        return;
      }
      
      // Fetch calibration data for the selected room
      const response = await fetch(`/api/room-calibration/${roomId}`);
      const result = await response.json();
      
      if (result.success) {
        const data = result.data.calibrationData;
        
        // Update electricity values
        document.getElementById('electricSensorValue').textContent = `${data.electricity.sensorValue || 0} kWh`;
        document.getElementById('electricActualValue').textContent = `${data.electricity.actualValue || 0} kWh`;
        document.getElementById('electricOffset').textContent = data.electricity.offset || 0;
        document.getElementById('electricCalibrationFactor').textContent = data.electricity.calibrationFactor || 1;
        document.getElementById('electricCalibrationDate').textContent = data.electricity.calibratedAt 
          ? new Date(data.electricity.calibratedAt).toLocaleDateString('vi-VN') 
          : 'Ch∆∞a hi·ªáu chu·∫©n';
        
        // Update water values  
        document.getElementById('waterSensorValue').textContent = `${data.water.sensorValue || 0} m¬≥`;
        document.getElementById('waterActualValue').textContent = `${data.water.actualValue || 0} m¬≥`;
        document.getElementById('waterCalibrationFactor').textContent = data.water.calibrationFactor || 1;
        document.getElementById('waterCalibrationDate').textContent = data.water.calibratedAt 
          ? new Date(data.water.calibratedAt).toLocaleDateString('vi-VN') 
          : 'Ch∆∞a hi·ªáu chu·∫©n';
          
        // Store calibration and lastData for later use
        window.currentRoomCalibrationData = result.data;
        currentElectricCalibrationData = data.electricity;
      } else {
        console.error('Error loading room calibration data:', result.error);
      }
    } catch (error) {
      console.error('Error loading room calibration data:', error);
    }
  }
  
  // ==================== ELECTRIC INITIAL CALIBRATION ====================
  
  // Open electric initial calibration modal
  function openElectricInitialCalibrationModal() {
    try {
      // Check if there are any rooms available
      const roomSelect = document.getElementById('calibrationRoomSelect');
      if (!roomSelect.value) {
        alert('Kh√¥ng c√≥ ph√≤ng n√†o c√≥ c·∫£m bi·∫øn ƒëi·ªán. Vui l√≤ng th√™m nodes v√†o ph√≤ng tr∆∞·ªõc.');
        return;
      }

      // Reset form
      document.getElementById('electricInitialSensorValue').value = '';
      document.getElementById('electricInitialMeterValue').value = '';
      document.getElementById('electricInitialPreview').style.display = 'none';
      
      // Show modal
      new bootstrap.Modal(document.getElementById('electricInitialCalibrationModal')).show();
      
    } catch (error) {
      console.error('Error opening electric initial calibration modal:', error);
      if (typeof toastManager !== 'undefined') {
        toastManager.error('L·ªói khi m·ªü modal hi·ªáu chu·∫©n ban ƒë·∫ßu: ' + error.message);
      } else {
        alert('L·ªói khi m·ªü modal hi·ªáu chu·∫©n ban ƒë·∫ßu: ' + error.message);
      }
    }
  }
  
  // Calculate and preview electric initial calibration
  function updateElectricInitialPreview() {
    try {
      const sensorValue = parseFloat(document.getElementById('electricInitialSensorValue').value);
      const meterValue = parseFloat(document.getElementById('electricInitialMeterValue').value);
      
      if (sensorValue > 0 && meterValue > 0) {
        const offset = meterValue - sensorValue;
        
        document.getElementById('electricInitialOffsetPreview').textContent = offset.toFixed(4);
        document.getElementById('electricInitialPreview').style.display = 'block';
      } else {
        document.getElementById('electricInitialPreview').style.display = 'none';
      }
    } catch (error) {
      document.getElementById('electricInitialPreview').style.display = 'none';
    }
  }
  
  // Submit electric initial calibration
  async function submitElectricInitialCalibration() {
    try {
      const sensorValue = parseFloat(document.getElementById('electricInitialSensorValue').value);
      const meterValue = parseFloat(document.getElementById('electricInitialMeterValue').value);
      const roomId = document.getElementById('calibrationRoomSelect').value;
      
      // Validation
      if (!roomId) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn');
        return;
      }
      
      if (!sensorValue || sensorValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã c·∫£m bi·∫øn h·ª£p l·ªá');
        return;
      }
      
      if (!meterValue || meterValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã ƒë·ªìng h·ªì h·ª£p l·ªá');
        return;
      }
      
      // Disable submit button
      const submitBtn = event.target;
      const originalText = submitBtn.innerHTML;
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêang l∆∞u...';
      
      // Calculate offset
      const offset = meterValue - sensorValue;
      
      // Prepare data
      const calibrationData = {
        type: 'electricity',
        roomId,
        isInitialCalibration: true,
        offset: offset,
        calibrationFactor: 1,
        firstSensorValue: sensorValue,
        firstActualValue: meterValue
      };
      
      console.log('üì§ Sending electric initial calibration data:', JSON.stringify(calibrationData, null, 2));
      
      // Send request
      const response = await fetch('/api/update-calibration', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(calibrationData)
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error);
      }

      // Update UI
      updateElectricCalibrationUI(result.data);

      // Show success message
      if (typeof toastManager !== 'undefined') {
        toastManager.success(`ƒê√£ thi·∫øt l·∫≠p hi·ªáu chu·∫©n ban ƒë·∫ßu ƒëi·ªán cho ph√≤ng ${roomId}`);
      } else {
        alert(`ƒê√£ thi·∫øt l·∫≠p hi·ªáu chu·∫©n ban ƒë·∫ßu ƒëi·ªán cho ph√≤ng ${roomId}`);
      }

      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('electricInitialCalibrationModal'));
      modal.hide();

      // Reload calibration data
      await loadRoomCalibrationData();

      // Reset button
      submitBtn.disabled = false;
      submitBtn.innerHTML = originalText;

    } catch (error) {
      console.error('Error submitting electric initial calibration:', error);

      // Reset button
      const submitBtn = event.target;
      submitBtn.disabled = false;
      submitBtn.innerHTML = '<i class="fas fa-save"></i> L∆∞u hi·ªáu chu·∫©n ban ƒë·∫ßu';
      
      alert('L·ªói khi l∆∞u hi·ªáu chu·∫©n ban ƒë·∫ßu: ' + error.message);
    }
  }

  // ==================== ELECTRIC ERROR CORRECTION ====================
  
  // Open electric error correction modal
  function openElectricErrorCorrectionModal() {
    try {
      // Check if there are any rooms available
      const roomSelect = document.getElementById('calibrationRoomSelect');
      if (!roomSelect.value) {
        alert('Kh√¥ng c√≥ ph√≤ng n√†o c√≥ c·∫£m bi·∫øn ƒëi·ªán. Vui l√≤ng th√™m nodes v√†o ph√≤ng tr∆∞·ªõc.');
        return;
      }

      // Check if there's initial calibration data
      if (!currentElectricCalibrationData || 
          currentElectricCalibrationData.firstSensorValue === undefined || 
          currentElectricCalibrationData.firstActualValue === undefined) {
        alert('Ch∆∞a c√≥ d·ªØ li·ªáu hi·ªáu chu·∫©n ban ƒë·∫ßu. Vui l√≤ng th·ª±c hi·ªán hi·ªáu chu·∫©n ban ƒë·∫ßu tr∆∞·ªõc.');
        return;
      }

      // Display existing calibration data
      document.getElementById('electricErrorFirstSensorValue').textContent = `${currentElectricCalibrationData.firstSensorValue} kWh`;
      document.getElementById('electricErrorFirstActualValue').textContent = `${currentElectricCalibrationData.firstActualValue} kWh`;
      document.getElementById('electricErrorCurrentOffset').textContent = currentElectricCalibrationData.offset || '0';
      document.getElementById('electricErrorCurrentCalibrationFactor').textContent = currentElectricCalibrationData.calibrationFactor || '1';
      
      // Reset form
      document.getElementById('electricErrorCurrentSensorValue').value = '';
      document.getElementById('electricErrorCurrentMeterValue').value = '';
      document.getElementById('electricErrorPreview').style.display = 'none';
      
      // Show modal
      new bootstrap.Modal(document.getElementById('electricErrorCorrectionModal')).show();
      
    } catch (error) {
      console.error('Error opening electric error correction modal:', error);
      if (typeof toastManager !== 'undefined') {
        toastManager.error('L·ªói khi m·ªü modal hi·ªáu chu·∫©n sai s·ªë: ' + error.message);
      } else {
        alert('L·ªói khi m·ªü modal hi·ªáu chu·∫©n sai s·ªë: ' + error.message);
      }
    }
  }
  
  // Calculate and preview electric error correction
  function updateElectricErrorPreview() {
    try {
      const currentSensorValue = parseFloat(document.getElementById('electricErrorCurrentSensorValue').value);
      const currentMeterValue = parseFloat(document.getElementById('electricErrorCurrentMeterValue').value);
      
      if (!currentElectricCalibrationData || !currentSensorValue || !currentMeterValue) {
        document.getElementById('electricErrorPreview').style.display = 'none';
        return;
      }
      
      const firstSensorValue = currentElectricCalibrationData.firstSensorValue;
      const firstActualValue = currentElectricCalibrationData.firstActualValue;
      
      if (currentSensorValue > 0 && currentMeterValue > 0 && firstSensorValue && firstActualValue) {
        // Calculate new calibration factor
        const newCalibrationFactor = (currentMeterValue - firstActualValue) / (currentSensorValue - firstSensorValue);
        
        // Calculate new offset
        const newOffset = firstActualValue - (firstSensorValue * newCalibrationFactor);
        
        // Update preview
        document.getElementById('electricErrorNewCalibrationFactor').textContent = newCalibrationFactor.toFixed(4);
        document.getElementById('electricErrorNewOffset').textContent = newOffset.toFixed(4);
        document.getElementById('electricErrorCalibrationFormula').textContent = 
          `(${currentMeterValue} - ${firstActualValue}) / (${currentSensorValue} - ${firstSensorValue})`;
        document.getElementById('electricErrorOffsetFormula').textContent = 
          `${firstActualValue} - (${firstSensorValue} √ó ${newCalibrationFactor.toFixed(4)})`;
        
        document.getElementById('electricErrorPreview').style.display = 'block';
      } else {
        document.getElementById('electricErrorPreview').style.display = 'none';
      }
    } catch (error) {
      document.getElementById('electricErrorPreview').style.display = 'none';
    }
  }
  
  // Submit electric error correction
  async function submitElectricErrorCorrection() {
    try {
      const currentSensorValue = parseFloat(document.getElementById('electricErrorCurrentSensorValue').value);
      const currentMeterValue = parseFloat(document.getElementById('electricErrorCurrentMeterValue').value);
      const roomId = document.getElementById('calibrationRoomSelect').value;
      
      // Validation
      if (!roomId) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn');
        return;
      }
      
      if (!currentSensorValue || currentSensorValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã c·∫£m bi·∫øn hi·ªán t·∫°i h·ª£p l·ªá');
        return;
      }
      
      if (!currentMeterValue || currentMeterValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã ƒë·ªìng h·ªì hi·ªán t·∫°i h·ª£p l·ªá');
        return;
      }
      
      if (!currentElectricCalibrationData) {
        alert('Kh√¥ng c√≥ d·ªØ li·ªáu hi·ªáu chu·∫©n ban ƒë·∫ßu');
        return;
      }
      
      // Disable submit button
      const submitBtn = event.target;
      const originalText = submitBtn.innerHTML;
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêang l∆∞u...';
      
      const firstSensorValue = currentElectricCalibrationData.firstSensorValue;
      const firstActualValue = currentElectricCalibrationData.firstActualValue;
      
      // Calculate new calibration factor and offset
      const newCalibrationFactor = (currentMeterValue - firstActualValue) / (currentSensorValue - firstSensorValue);
      const newOffset = firstActualValue - (firstSensorValue * newCalibrationFactor);
      
      // Prepare data
      const calibrationData = {
        type: 'electricity',
        roomId,
        isErrorCorrection: true,
        offset: newOffset,
        calibrationFactor: newCalibrationFactor,
        firstSensorValue: firstSensorValue,
        firstActualValue: firstActualValue,
        currentSensorValue: currentSensorValue,
        currentMeterValue: currentMeterValue
      };
      
      console.log('üì§ Sending electric error correction data:', JSON.stringify(calibrationData, null, 2));
      
      // Send request
      const response = await fetch('/api/update-calibration', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(calibrationData)
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error);
      }

      // Update UI
      updateElectricCalibrationUI(result.data);

      // Show success message
      if (typeof toastManager !== 'undefined') {
        toastManager.success(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu ch·ªânh sai s·ªë ƒëi·ªán cho ph√≤ng ${roomId}`);
      } else {
        alert(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu ch·ªânh sai s·ªë ƒëi·ªán cho ph√≤ng ${roomId}`);
      }

      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('electricErrorCorrectionModal'));
      modal.hide();

      // Reload calibration data
      await loadRoomCalibrationData();

      // Reset button
      submitBtn.disabled = false;
      submitBtn.innerHTML = originalText;

    } catch (error) {
      console.error('Error submitting electric error correction:', error);

      // Reset button
      const submitBtn = event.target;
      submitBtn.disabled = false;
      submitBtn.innerHTML = '<i class="fas fa-save"></i> L∆∞u hi·ªáu chu·∫©n sai s·ªë';
      
      alert('L·ªói khi l∆∞u hi·ªáu ch·ªânh sai s·ªë: ' + error.message);
    }
  }

  // ==================== WATER CALIBRATION (OLD LOGIC) ====================
  
  // Open water calibration modal (keep old logic)
  function openCalibrationModal(type) {
    if (type !== 'water') return; // Only handle water here
    
    try {
      // Check if there are any rooms available
      const roomSelect = document.getElementById('calibrationRoomSelect');
      if (!roomSelect.value) {
        alert('Kh√¥ng c√≥ ph√≤ng n√†o c√≥ c·∫£m bi·∫øn n∆∞·ªõc. Vui l√≤ng th√™m nodes v√†o ph√≤ng tr∆∞·ªõc.');
        return;
      }
      
      // Reset form
      document.getElementById('waterSensorValue').value = '';
      document.getElementById('waterActualValue').value = '';
      document.getElementById('waterCalibrationPreview').style.display = 'none';
      
      // Handle water-specific logic (keep old behavior)
      if (window.currentRoomCalibrationData) {
        const waterLastData = window.currentRoomCalibrationData.lastData.water;
        const waterCalibration = window.currentRoomCalibrationData.calibrationData.water;
        
        if (waterLastData && waterLastData.water !== null && waterLastData.water !== undefined) {
          // T√≠nh gi√° tr·ªã th√¥ = lastData / h·ªá s·ªë c≈© (n·∫øu c√≥), n·∫øu kh√¥ng c√≥ h·ªá s·ªë th√¨ gi·ªØ nguy√™n
          const oldCalibrationFactor = waterCalibration.calibrationFactor || 1.0;
          const currentRawValue = waterLastData.water / oldCalibrationFactor;
          
          document.getElementById('currentRawSensorValue').value = currentRawValue.toFixed(3);
          document.getElementById('waterSensorValue').value = waterLastData.water.toFixed(3);
          document.getElementById('currentRawSensorGroup').style.display = 'block';
          document.getElementById('waterNoDataAlert').style.display = 'none';
        } else {
          document.getElementById('currentRawSensorValue').value = '';
          document.getElementById('currentRawSensorValue').placeholder = 'Ch∆∞a c√≥ d·ªØ li·ªáu c·∫£m bi·∫øn';
          document.getElementById('currentRawSensorGroup').style.display = 'block';
          document.getElementById('waterNoDataAlert').style.display = 'block';
        }
      }
      
      // Show modal
      new bootstrap.Modal(document.getElementById('waterCalibrationModal')).show();
      
    } catch (error) {
      console.error('Error opening water calibration modal:', error);
      if (typeof toastManager !== 'undefined') {
        toastManager.error('L·ªói khi m·ªü modal hi·ªáu chu·∫©n n∆∞·ªõc: ' + error.message);
      } else {
        alert('L·ªói khi m·ªü modal hi·ªáu chu·∫©n n∆∞·ªõc: ' + error.message);
      }
    }
  }
  
  // Calculate and preview water calibration
  function updateWaterCalibrationPreview() {
    try {
      const sensorValue = parseFloat(document.getElementById('waterSensorValue').value);
      const actualValue = parseFloat(document.getElementById('waterActualValue').value);
      
      let calibrationFactor = 0;
      let formula = '';
      
        // Cho n∆∞·ªõc: ki·ªÉm tra xem c√≥ gi√° tr·ªã th√¥ hay kh√¥ng
        const currentRawSensorValue = parseFloat(document.getElementById('currentRawSensorValue').value);
        
        if (currentRawSensorValue && currentRawSensorValue > 0 && actualValue > 0) {
          // C√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng gi√° tr·ªã th√¥
          calibrationFactor = actualValue / currentRawSensorValue;
          formula = 'Gi√° tr·ªã th·ª±c = C·∫£m bi·∫øn th√¥ √ó H·ªá s·ªë';
        } else if (sensorValue > 0 && actualValue > 0) {
        // Ch∆∞a c√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng sensorValue
          calibrationFactor = actualValue / sensorValue;
          formula = 'Gi√° tr·ªã th·ª±c = C·∫£m bi·∫øn hi·ªÉn th·ªã √ó H·ªá s·ªë';
      }
      
      if (calibrationFactor > 0) {
        document.getElementById('waterPreviewCalibrationFactor').textContent = calibrationFactor.toFixed(4);
        document.getElementById('waterPreviewFormula').textContent = formula;
        document.getElementById('waterCalibrationPreview').style.display = 'block';
      } else {
        document.getElementById('waterCalibrationPreview').style.display = 'none';
      }
    } catch (error) {
      document.getElementById('waterCalibrationPreview').style.display = 'none';
    }
  }
  
  // Submit water calibration (old logic)
  async function submitWaterCalibration() {
    try {
      const sensorValue = parseFloat(document.getElementById('waterSensorValue').value);
      const actualValue = parseFloat(document.getElementById('waterActualValue').value);
      const roomId = document.getElementById('calibrationRoomSelect').value;
      
      // Validation
      if (!roomId) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn');
        return;
      }
      
      if (!sensorValue || sensorValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã c·∫£m bi·∫øn h·ª£p l·ªá');
        return;
      }
      
      if (!actualValue || actualValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã th·ª±c t·∫ø h·ª£p l·ªá');
        return;
      }
      
      // Disable submit button
      const submitBtn = event.target;
      const originalText = submitBtn.innerHTML;
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêang l∆∞u...';

      // Prepare old-style data for water
      let calibrationData = {
        type: 'water',
        roomId,
        sensorValue,
        actualValue
      };
      
      // Cho n∆∞·ªõc, c·∫ßn ki·ªÉm tra th√™m currentRawSensorValue
      const currentRawSensorValue = parseFloat(document.getElementById('currentRawSensorValue').value);
        if (currentRawSensorValue && currentRawSensorValue > 0) {
          // C√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng gi√° tr·ªã th√¥
          calibrationData.currentRawSensorValue = currentRawSensorValue;
        } else {
        // Ch∆∞a c√≥ d·ªØ li·ªáu lastData, s·ª≠ d·ª•ng sensorValue
        calibrationData.useDisplayValue = true;
      }

      console.log('üì§ Sending water calibration data:', JSON.stringify(calibrationData, null, 2));

      // Send request to old endpoint (you'll need to add this back for water)
      const response = await fetch('/api/update-calibration-water', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(calibrationData)
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error);
      }

      // Update UI
      updateWaterCalibrationUI(result.data);

      // Show success message
      if (typeof toastManager !== 'undefined') {
        toastManager.success(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu chu·∫©n n∆∞·ªõc cho ph√≤ng ${roomId}`);
      } else {
        alert(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu chu·∫©n n∆∞·ªõc cho ph√≤ng ${roomId}`);
      }

      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('waterCalibrationModal'));
      modal.hide();

      // Reload calibration data
      await loadRoomCalibrationData();

      // Reset button
      submitBtn.disabled = false;
      submitBtn.innerHTML = originalText;

    } catch (error) {
      console.error('Error submitting water calibration:', error);

      // Reset button
      const submitBtn = event.target;
      submitBtn.disabled = false;
      submitBtn.innerHTML = '<i class="fas fa-save"></i> L∆∞u hi·ªáu chu·∫©n';
      
      alert('L·ªói khi l∆∞u hi·ªáu chu·∫©n n∆∞·ªõc: ' + error.message);
    }
  }

  // ==================== UI UPDATE FUNCTIONS ====================
  
  // Update electric calibration UI
  function updateElectricCalibrationUI(data) {
    document.getElementById('electricSensorValue').textContent = `${data.firstSensorValue || 0} kWh`;
    document.getElementById('electricActualValue').textContent = `${data.firstActualValue || 0} kWh`;
    document.getElementById('electricOffset').textContent = data.offset || 0;
    document.getElementById('electricCalibrationFactor').textContent = data.calibrationFactor || 1;
    document.getElementById('electricCalibrationDate').textContent = new Date().toLocaleDateString('vi-VN');
  }

  // Update water calibration UI (old style)
  function updateWaterCalibrationUI(data) {
    document.getElementById('waterSensorValue').textContent = `${data.sensorValue || 0} m¬≥`;
    document.getElementById('waterActualValue').textContent = `${data.actualValue || 0} m¬≥`;
    document.getElementById('waterCalibrationFactor').textContent = data.calibrationFactor || 1;
    document.getElementById('waterCalibrationDate').textContent = new Date().toLocaleDateString('vi-VN');
  }

  // ==================== EVENT LISTENERS ====================

  // Add event listeners for real-time preview updates
  document.addEventListener('DOMContentLoaded', function() {
    // Electric initial calibration inputs
    const electricInitialSensorInput = document.getElementById('electricInitialSensorValue');
    const electricInitialMeterInput = document.getElementById('electricInitialMeterValue');
    
    if (electricInitialSensorInput) {
      electricInitialSensorInput.addEventListener('input', updateElectricInitialPreview);
    }
    if (electricInitialMeterInput) {
      electricInitialMeterInput.addEventListener('input', updateElectricInitialPreview);
    }
    
    // Electric error correction inputs
    const electricErrorSensorInput = document.getElementById('electricErrorCurrentSensorValue');
    const electricErrorMeterInput = document.getElementById('electricErrorCurrentMeterValue');
    
    if (electricErrorSensorInput) {
      electricErrorSensorInput.addEventListener('input', updateElectricErrorPreview);
    }
    if (electricErrorMeterInput) {
      electricErrorMeterInput.addEventListener('input', updateElectricErrorPreview);
    }
    
    // Water calibration inputs (old modal)
    const waterSensorInput = document.getElementById('waterSensorValue');
    const waterActualInput = document.getElementById('waterActualValue');
    
    if (waterSensorInput) {
      waterSensorInput.addEventListener('input', updateWaterCalibrationPreview);
    }
    if (waterActualInput) {
      waterActualInput.addEventListener('input', updateWaterCalibrationPreview);
    }
    
    // Water error correction inputs (new modal)
    const waterErrorSensorInput = document.getElementById('waterCurrentSensorValue');
    const waterErrorMeterInput = document.getElementById('waterCurrentMeterValue');
    
    if (waterErrorSensorInput) {
      waterErrorSensorInput.addEventListener('input', calculateWaterPreview);
    }
    if (waterErrorMeterInput) {
      waterErrorMeterInput.addEventListener('input', calculateWaterPreview);
    }
  });

  // ==================== WATER INITIAL CALIBRATION (NEW) ====================
  
  // Open water initial calibration modal
  function openWaterInitialCalibrationModal() {
    try {
      // Check if there are any rooms available
      const roomSelect = document.getElementById('calibrationRoomSelect');
      if (!roomSelect.value) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn n∆∞·ªõc tr∆∞·ªõc.');
        return;
      }

      const roomId = roomSelect.value;
      const roomName = roomSelect.options[roomSelect.selectedIndex].text;

      // Ki·ªÉm tra c√≥ water node kh√¥ng
      const nodeId = getWaterNodeIdForRoom(roomId);
      if (!nodeId) {
        alert('Ph√≤ng n√†y kh√¥ng c√≥ c·∫£m bi·∫øn n∆∞·ªõc. Vui l√≤ng ch·ªçn ph√≤ng kh√°c.');
        return;
      }

      // Hi·ªÉn th·ªã t√™n ph√≤ng ƒë√£ ch·ªçn
      document.getElementById('waterInitialSelectedRoom').textContent = roomName;

      // Reset form
      document.getElementById('waterMeterValue').value = '';
      
      // Show modal
      new bootstrap.Modal(document.getElementById('waterInitialCalibrationModal')).show();
      
    } catch (error) {
      console.error('Error opening water initial calibration modal:', error);
      if (typeof toastManager !== 'undefined') {
        toastManager.error('L·ªói khi m·ªü modal hi·ªáu chu·∫©n ban ƒë·∫ßu n∆∞·ªõc: ' + error.message);
      } else {
        alert('L·ªói khi m·ªü modal hi·ªáu chu·∫©n ban ƒë·∫ßu n∆∞·ªõc: ' + error.message);
      }
    }
  }
  
  // Submit water initial calibration (send via setNodePeriod API)
  async function submitWaterInitialCalibration() {
    try {
      const waterMeterValue = parseFloat(document.getElementById('waterMeterValue').value);
      
      // L·∫•y roomId t·ª´ dropdown ch√≠nh
      const roomSelect = document.getElementById('calibrationRoomSelect');
      const roomId = roomSelect.value;
      
      // Validation
      if (!roomId) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn n∆∞·ªõc');
        return;
      }
      
      if (!waterMeterValue || waterMeterValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã ƒë·ªìng h·ªì n∆∞·ªõc h·ª£p l·ªá');
        return;
      }
      
      // Disable submit button
      const submitBtn = event.target;
      const originalText = submitBtn.innerHTML;
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêang g·ª≠i...';
      
      // Get nodeId for water sensor in this room
      const nodeId = getWaterNodeIdForRoom(roomId);
      if (!nodeId) {
        throw new Error('Kh√¥ng t√¨m th·∫•y c·∫£m bi·∫øn n∆∞·ªõc trong ph√≤ng n√†y');
      }
      
      // Prepare data for setNodePeriod API (send water:value like period:value)
      const requestData = {
        nodeId: nodeId,
        waterValue: waterMeterValue // This will be converted to water:value base64
      };
      
      console.log('üì§ Sending water initial calibration via setNodePeriod:', JSON.stringify(requestData, null, 2));
      
      // Send request to a new endpoint that handles water initial calibration
      const response = await fetch('/api/set-water-initial-calibration', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData)
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error);
      }

      // Sau khi g·ª≠i l·ªánh th√†nh c√¥ng, l∆∞u d·ªØ li·ªáu calibration ban ƒë·∫ßu l√™n Firebase
      console.log('üì§ Sending water initial calibration data to Firebase...');
      
      const calibrationResponse = await fetch('/api/update-calibration-water', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          type: 'water',
          roomId,
          isInitialCalibration: true,
          offset: 0, // Ban ƒë·∫ßu offset = 0
          calibrationFactor: 1, // Ban ƒë·∫ßu calibrationFactor = 1
          firstSensorValue: waterMeterValue, // C·∫£m bi·∫øn s·∫Ω ƒë∆∞·ª£c set th√†nh gi√° tr·ªã n√†y
          firstActualValue: waterMeterValue, // Gi√° tr·ªã ƒë·ªìng h·ªì ng∆∞·ªùi d√πng nh·∫≠p
          initialMeterValue: waterMeterValue // L∆∞u gi√° tr·ªã ban ƒë·∫ßu ƒë·ªÉ tham kh·∫£o
        })
      });

      const calibrationResult = await calibrationResponse.json();
      
      if (!calibrationResult.success) {
        console.warn('G·ª≠i l·ªánh th√†nh c√¥ng nh∆∞ng l∆∞u calibration data th·∫•t b·∫°i:', calibrationResult.error);
        // V·∫´n show success v√¨ l·ªánh ƒë√£ g·ª≠i th√†nh c√¥ng
      } else {
        // Update UI n·∫øu l∆∞u calibration data th√†nh c√¥ng
        updateWaterCalibrationUINew(calibrationResult.data);
      }

      // Show success message
      if (typeof toastManager !== 'undefined') {
        toastManager.success(`ƒê√£ g·ª≠i l·ªánh v√† l∆∞u hi·ªáu chu·∫©n ban ƒë·∫ßu n∆∞·ªõc cho ph√≤ng ${roomId}`);
      } else {
        alert(`ƒê√£ g·ª≠i l·ªánh v√† l∆∞u hi·ªáu chu·∫©n ban ƒë·∫ßu n∆∞·ªõc cho ph√≤ng ${roomId}`);
      }

      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('waterInitialCalibrationModal'));
      modal.hide();

      // Reload calibration data ƒë·ªÉ c·∫≠p nh·∫≠t UI
      await loadRoomCalibrationData();

      // Reset button
      submitBtn.disabled = false;
      submitBtn.innerHTML = originalText;

    } catch (error) {
      console.error('Error submitting water initial calibration:', error);

      // Reset button
      const submitBtn = event.target;
      submitBtn.disabled = false;
      submitBtn.innerHTML = '<i class="fas fa-save"></i> L∆∞u hi·ªáu chu·∫©n ban ƒë·∫ßu';
      
      alert('L·ªói khi g·ª≠i hi·ªáu chu·∫©n ban ƒë·∫ßu n∆∞·ªõc: ' + error.message);
    }
  }

  // ==================== WATER ERROR CORRECTION (NEW) ====================
  
  let currentWaterCalibrationData = null; // L∆∞u tr·ªØ d·ªØ li·ªáu hi·ªáu chu·∫©n n∆∞·ªõc hi·ªán t·∫°i
  
  // Open water error correction modal
  function openWaterErrorCorrectionModal() {
    try {
      // Check if there are any rooms available
      const roomSelect = document.getElementById('calibrationRoomSelect');
      if (!roomSelect.value) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn n∆∞·ªõc tr∆∞·ªõc.');
        return;
      }

      const roomId = roomSelect.value;

      // Ki·ªÉm tra c√≥ water node kh√¥ng
      const nodeId = getWaterNodeIdForRoom(roomId);
      if (!nodeId) {
        alert('Ph√≤ng n√†y kh√¥ng c√≥ c·∫£m bi·∫øn n∆∞·ªõc. Vui l√≤ng ch·ªçn ph√≤ng kh√°c.');
        return;
      }

      // Get current water calibration data from window.currentRoomCalibrationData
      if (window.currentRoomCalibrationData) {
        currentWaterCalibrationData = window.currentRoomCalibrationData.calibrationData.water;
      }

      // Check if there's initial calibration data
      if (!currentWaterCalibrationData || 
          currentWaterCalibrationData.firstSensorValue === undefined || 
          currentWaterCalibrationData.firstActualValue === undefined) {
        alert('Ch∆∞a c√≥ d·ªØ li·ªáu hi·ªáu chu·∫©n ban ƒë·∫ßu n∆∞·ªõc. Vui l√≤ng th·ª±c hi·ªán hi·ªáu chu·∫©n ban ƒë·∫ßu tr∆∞·ªõc.');
        return;
      }

      // Modal m·ªõi kh√¥ng hi·ªÉn th·ªã t√™n ph√≤ng (gi·ªëng nh∆∞ modal ƒëi·ªán)

      // Display existing calibration data
      console.log('üîç Current Water Calibration Data:', currentWaterCalibrationData);
      
      document.getElementById('waterErrorFirstSensorValue').textContent = `${currentWaterCalibrationData.firstSensorValue || 'N/A'}`;
      document.getElementById('waterErrorFirstActualValue').textContent = `${currentWaterCalibrationData.firstActualValue || 'N/A'}`;
      document.getElementById('waterErrorCurrentOffset').textContent = currentWaterCalibrationData.offset || '0';
      document.getElementById('waterErrorCurrentCalibrationFactor').textContent = currentWaterCalibrationData.calibrationFactor || '1';

      // Reset form
      document.getElementById('waterCurrentSensorValue').value = '';
      document.getElementById('waterCurrentMeterValue').value = '';
      document.getElementById('waterErrorPreview').style.display = 'none';
      
      // Show modal
      new bootstrap.Modal(document.getElementById('waterErrorCorrectionModal')).show();
      
    } catch (error) {
      console.error('Error opening water error correction modal:', error);
      if (typeof toastManager !== 'undefined') {
        toastManager.error('L·ªói khi m·ªü modal hi·ªáu chu·∫©n sai s·ªë n∆∞·ªõc: ' + error.message);
      } else {
        alert('L·ªói khi m·ªü modal hi·ªáu chu·∫©n sai s·ªë n∆∞·ªõc: ' + error.message);
      }
    }
  }
  
  // Calculate and preview water error correction
  function calculateWaterPreview() {
    try {
      const currentSensorValue = parseFloat(document.getElementById('waterCurrentSensorValue').value);
      const currentMeterValue = parseFloat(document.getElementById('waterCurrentMeterValue').value);
      
      if (!currentWaterCalibrationData || !currentSensorValue || !currentMeterValue) {
        document.getElementById('waterErrorPreview').style.display = 'none';
        return;
      }
      
      const firstSensorValue = currentWaterCalibrationData.firstSensorValue;
      const firstActualValue = currentWaterCalibrationData.firstActualValue;
      
      // Debug log
      console.log('Water Preview Calculation:', {
        currentSensorValue,
        currentMeterValue,
        firstSensorValue,
        firstActualValue,
        sensorDifference: currentSensorValue - firstSensorValue,
        meterDifference: currentMeterValue - firstActualValue
      });
      
      if (currentSensorValue > 0 && currentMeterValue > 0 && firstSensorValue !== undefined && firstActualValue !== undefined) {
        const sensorDifference = currentSensorValue - firstSensorValue;
        const meterDifference = currentMeterValue - firstActualValue;
        
        // Ki·ªÉm tra chia cho 0
        if (Math.abs(sensorDifference) < 0.001) {
          // N·∫øu sensorDifference qu√° nh·ªè (g·∫ßn b·∫±ng 0)
          document.getElementById('waterErrorNewCalibrationFactor').textContent = 'L·ªói: Gi√° tr·ªã c·∫£m bi·∫øn kh√¥ng thay ƒë·ªïi';
          document.getElementById('waterErrorNewOffset').textContent = 'L·ªói: Kh√¥ng th·ªÉ t√≠nh to√°n';
          document.getElementById('waterErrorCalibrationFormula').textContent = 
            `(${currentMeterValue} - ${firstActualValue}) / (${currentSensorValue} - ${firstSensorValue}) = Chia cho 0`;
          document.getElementById('waterErrorOffsetFormula').textContent = 'Kh√¥ng th·ªÉ t√≠nh to√°n';
        } else {
          // Calculate new calibration factor
          const newCalibrationFactor = meterDifference / sensorDifference;
          
          // Calculate new offset
          const newOffset = firstActualValue - (firstSensorValue * newCalibrationFactor);
          
          // Update preview
          document.getElementById('waterErrorNewCalibrationFactor').textContent = newCalibrationFactor.toFixed(4);
          document.getElementById('waterErrorNewOffset').textContent = newOffset.toFixed(4);
          document.getElementById('waterErrorCalibrationFormula').textContent = 
            `(${currentMeterValue} - ${firstActualValue}) / (${currentSensorValue} - ${firstSensorValue})`;
          document.getElementById('waterErrorOffsetFormula').textContent = 
            `${firstActualValue} - (${firstSensorValue} √ó ${newCalibrationFactor.toFixed(4)})`;
        }
        
        document.getElementById('waterErrorPreview').style.display = 'block';
      } else {
        document.getElementById('waterErrorPreview').style.display = 'none';
      }
    } catch (error) {
      console.error('Error in calculateWaterPreview:', error);
      document.getElementById('waterErrorPreview').style.display = 'none';
    }
  }
  
  // Submit water error correction
  async function submitWaterErrorCorrection() {
    try {
      const currentSensorValue = parseFloat(document.getElementById('waterCurrentSensorValue').value);
      const currentMeterValue = parseFloat(document.getElementById('waterCurrentMeterValue').value);
      
      // L·∫•y roomId t·ª´ dropdown ch√≠nh
      const roomSelect = document.getElementById('calibrationRoomSelect');
      const roomId = roomSelect.value;
      
      // Validation
      if (!roomId) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng c√≥ c·∫£m bi·∫øn n∆∞·ªõc');
        return;
      }
      
      if (!currentSensorValue || currentSensorValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã c·∫£m bi·∫øn hi·ªán t·∫°i h·ª£p l·ªá');
        return;
      }
      
      if (!currentMeterValue || currentMeterValue <= 0) {
        alert('Vui l√≤ng nh·∫≠p gi√° tr·ªã ƒë·ªìng h·ªì hi·ªán t·∫°i h·ª£p l·ªá');
        return;
      }
      
      if (!currentWaterCalibrationData) {
        alert('Kh√¥ng c√≥ d·ªØ li·ªáu hi·ªáu chu·∫©n ban ƒë·∫ßu n∆∞·ªõc');
        return;
      }
      
      // Disable submit button
      const submitBtn = event.target;
      const originalText = submitBtn.innerHTML;
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêang l∆∞u...';
      
      const firstSensorValue = currentWaterCalibrationData.firstSensorValue;
      const firstActualValue = currentWaterCalibrationData.firstActualValue;
      
      // Calculate new calibration factor and offset
      const newCalibrationFactor = (currentMeterValue - firstActualValue) / (currentSensorValue - firstSensorValue);
      const newOffset = firstActualValue - (firstSensorValue * newCalibrationFactor);
      
      // Prepare data for water error correction
      const calibrationData = {
        type: 'water',
        roomId,
        isErrorCorrection: true,
        offset: newOffset,
        calibrationFactor: newCalibrationFactor,
        firstSensorValue: firstSensorValue,
        firstActualValue: firstActualValue,
        currentSensorValue: currentSensorValue,
        currentMeterValue: currentMeterValue
      };
      
      console.log('üì§ Sending water error correction data:', JSON.stringify(calibrationData, null, 2));
      
      // Send request to water calibration endpoint
      const response = await fetch('/api/update-calibration-water', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(calibrationData)
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error);
      }

      // Update UI for water
      updateWaterCalibrationUINew(result.data);

      // Show success message
      if (typeof toastManager !== 'undefined') {
        toastManager.success(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu ch·ªânh sai s·ªë n∆∞·ªõc cho ph√≤ng ${roomId}`);
      } else {
        alert(`ƒê√£ c·∫≠p nh·∫≠t hi·ªáu ch·ªânh sai s·ªë n∆∞·ªõc cho ph√≤ng ${roomId}`);
      }

      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('waterErrorCorrectionModal'));
      modal.hide();

      // Reload calibration data
      await loadRoomCalibrationData();

      // Reset button
      submitBtn.disabled = false;
      submitBtn.innerHTML = originalText;

    } catch (error) {
      console.error('Error submitting water error correction:', error);

      // Reset button
      const submitBtn = event.target;
      submitBtn.disabled = false;
      submitBtn.innerHTML = '<i class="fas fa-save"></i> L∆∞u hi·ªáu chu·∫©n sai s·ªë';
      
      alert('L·ªói khi l∆∞u hi·ªáu ch·ªânh sai s·ªë n∆∞·ªõc: ' + error.message);
    }
  }

  // ==================== WATER SENSOR VALUE FUNCTIONS ====================
  
  // Get current water sensor value from lastData
  function getWaterSensorValue() {
    try {
      // L·∫•y roomId hi·ªán t·∫°i
      const roomSelect = document.getElementById('calibrationRoomSelect');
      const roomId = roomSelect.value;
      
      if (!roomId) {
        alert('Vui l√≤ng ch·ªçn ph√≤ng tr∆∞·ªõc');
        return;
      }
      
      // Ki·ªÉm tra c√≥ d·ªØ li·ªáu kh√¥ng
      if (!window.currentRoomCalibrationData || !window.currentRoomCalibrationData.lastData) {
        alert('Kh√¥ng c√≥ d·ªØ li·ªáu c·∫£m bi·∫øn. Vui l√≤ng ƒë·ª£i c·∫£m bi·∫øn g·ª≠i d·ªØ li·ªáu.');
        return;
      }
      
      const waterLastData = window.currentRoomCalibrationData.lastData.water;
      
      if (!waterLastData || typeof waterLastData.rawWater !== 'number') {
        alert('Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu c·∫£m bi·∫øn n∆∞·ªõc. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi c·∫£m bi·∫øn.');
        return;
      }
      
      // ƒêi·ªÅn gi√° tr·ªã v√†o input
      const sensorInput = document.getElementById('waterCurrentSensorValue');
      sensorInput.value = waterLastData.rawWater.toFixed(3);
      
      // Trigger preview calculation
      calculateWaterPreview();
      
      // Show success message
      if (typeof toastManager !== 'undefined') {
        toastManager.success(`ƒê√£ l·∫•y gi√° tr·ªã c·∫£m bi·∫øn: ${waterLastData.rawWater.toFixed(3)} m¬≥`);
      }
      
      console.log('üîç Retrieved water sensor value:', {
        roomId,
        rawWater: waterLastData.rawWater,
        water: waterLastData.water,
        lastDataTimestamp: waterLastData.timestamp
      });
      
    } catch (error) {
      console.error('Error getting water sensor value:', error);
      alert('L·ªói khi l·∫•y gi√° tr·ªã c·∫£m bi·∫øn: ' + error.message);
    }
  }

  // ==================== HELPER FUNCTIONS ====================
  
  // Get water node ID for a room (s·ª≠ d·ª•ng window.allRoomsData gi·ªëng period-functions)
  function getWaterNodeIdForRoom(roomId) {
    try {
      if (!window.allRoomsData || !window.allRoomsData[roomId] || !window.allRoomsData[roomId].nodes) {
        console.error('No room data found for:', roomId);
        return null;
      }
      
      const nodes = window.allRoomsData[roomId].nodes;
      for (const [nodeId, node] of Object.entries(nodes)) {
        if (node.type === 'water') {
          console.log('Found water node:', nodeId, 'for room:', roomId);
          return nodeId;
        }
      }
      console.error('No water node found in room:', roomId);
      return null;
    } catch (error) {
      console.error('Error getting water node ID:', error);
      return null;
    }
  }

  // Update water calibration UI (new style with offset)
  function updateWaterCalibrationUINew(data) {
    // Hi·ªÉn th·ªã gi√° tr·ªã c·∫£m bi·∫øn (∆∞u ti√™n firstSensorValue, fallback sensorValue)
    const sensorValue = data.firstSensorValue !== undefined ? data.firstSensorValue : (data.sensorValue || 0);
    document.getElementById('waterSensorValue').textContent = `${sensorValue} m¬≥`;
    
    // Hi·ªÉn th·ªã gi√° tr·ªã th·ª±c t·∫ø (∆∞u ti√™n firstActualValue, fallback actualValue)  
    const actualValue = data.firstActualValue !== undefined ? data.firstActualValue : (data.actualValue || 0);
    document.getElementById('waterActualValue').textContent = `${actualValue} m¬≥`;
    
    document.getElementById('waterOffset').textContent = data.offset || 0;
    document.getElementById('waterCalibrationFactor').textContent = data.calibrationFactor || 1;
    document.getElementById('waterCalibrationDate').textContent = new Date().toLocaleDateString('vi-VN');
  }

       // Update loadRoomCalibrationData to include water offset
  const originalLoadRoomCalibrationData = loadRoomCalibrationData;
  loadRoomCalibrationData = async function() {
    await originalLoadRoomCalibrationData();
    
    // Add water offset display if available
    if (window.currentRoomCalibrationData) {
      const waterCalibration = window.currentRoomCalibrationData.calibrationData.water;
      console.log('üîç Water calibration data after load:', waterCalibration);
      
      if (waterCalibration.offset !== undefined) {
        document.getElementById('waterOffset').textContent = waterCalibration.offset;
      }
      
      // Update global water calibration data for error correction modal
      currentWaterCalibrationData = waterCalibration;
    }
  };

</script> 