    // ==================== FEEDBACK FUNCTIONS ====================
    
    // Initialize feedback system - try Firebase realtime first, fallback to API
    async function initializeFeedbackSystem() {
      console.log('üîÑ Initializing feedback system...');
      
      try {
        // Try to initialize Firebase first
        const firebaseReady = await initializeFirebase();
        
        if (firebaseReady && feedbackRef) {
          console.log('‚úÖ Firebase ready, setting up realtime listener...');
          setupFeedbackRealtimeListener();
        } else {
          console.log('‚ö†Ô∏è Firebase not available, using API fallback...');
          loadFeedbackFromAPI();
        }
        
      } catch (error) {
        console.error('‚ùå Error initializing feedback system:', error);
        console.log('üì± Falling back to API mode...');
        loadFeedbackFromAPI();
      }
    }
    
    // Setup realtime feedback listener
    function setupFeedbackRealtimeListener() {
      if (!feedbackRef) {
        console.error('‚ùå Firebase not initialized, falling back to API');
        loadFeedbackFromAPI();
        return;
      }
      
      try {
        
        const feedbackList = document.getElementById('feedbackList');
        
        // Show loading state
        feedbackList.innerHTML = `
          <div class="feedback-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <div>ƒêang k·∫øt n·ªëi realtime...</div>
          </div>
        `;
        
        console.log('üî¥ Setting up realtime feedback listener...');
        
        // Listen for data changes
        feedbackListener = feedbackRef.on('value', (snapshot) => {
          const feedbackData = snapshot.val() || {};
          console.log('üîÑ Realtime feedback update received:', Object.keys(feedbackData).length, 'items');
          console.log('üìä Raw feedback data:', feedbackData);
          
          // Convert to array and sort
          const feedbacks = [];
          
          Object.entries(feedbackData).forEach(([timestampKey, feedback]) => {
            feedbacks.push({
              id: timestampKey,
              timestamp: timestampKey,
              phone: feedback.phone || null,
              roomNumber: feedback.roomNumber || null,
              content: feedback.feedback || feedback.content || '',
              isAnonymous: !feedback.phone || feedback.phone === 'anonymous',
              createdAt: parseFeedbackTimestamp(timestampKey)
            });
          });
          
          // Sort by timestamp (newest first - for display order)
          feedbacks.sort((a, b) => b.createdAt - a.createdAt);
          
          // Limit to last 20 feedbacks
          const limitedFeedbacks = feedbacks.slice(0, 20);
          
          console.log('üìù Processed feedbacks:', limitedFeedbacks);
          
          // Update UI
          displayFeedbacks(limitedFeedbacks);
        }, (error) => {
          console.error('‚ùå Realtime listener error:', error);
          loadFeedbackFromAPI(); // Fallback to API
        });
        
      } catch (error) {
        console.error('‚ùå Error setting up realtime listener:', error);
        loadFeedbackFromAPI(); // Fallback to API
      }
    }
    
    // Fallback to API loading
    async function loadFeedbackFromAPI() {
      try {
        const feedbackList = document.getElementById('feedbackList');
        
        // Show loading state
        feedbackList.innerHTML = `
          <div class="feedback-loading">
            <i class="fas fa-spinner fa-spin"></i>
            <div>ƒêang t·∫£i g√≥p √Ω...</div>
          </div>
        `;
        
        const response = await fetch('/api/feedback');
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        
        const result = await response.json();
        console.log('üì° API Response:', result);
        
        // Extract data array from API response
        const feedbacks = result.data || [];
        console.log('üìù Feedbacks array:', feedbacks);
        
        displayFeedbacks(feedbacks);
        
      } catch (error) {
        console.error('L·ªói khi t·∫£i g√≥p √Ω t·ª´ API:', error);
        
        const feedbackList = document.getElementById('feedbackList');
        feedbackList.innerHTML = `
          <div class="feedback-empty">
            <i class="fas fa-exclamation-triangle text-warning"></i>
            <div>L·ªói khi t·∫£i g√≥p √Ω</div>
            <small class="text-muted">${error.message}</small>
          </div>
        `;
      }
    }
    
    // Display feedbacks in YouTube Live Chat style - v2.0 
    function displayFeedbacks(feedbacks) {
      const feedbackList = document.getElementById('feedbackList');
      
      if (feedbacks.length === 0) {
        feedbackList.innerHTML = `
          <div class="feedback-empty" style="color: #6b7280; text-align: center; padding: 40px 20px;">
            <i class="fas fa-comments" style="font-size: 2em; margin-bottom: 12px; display: block; color: #d1d5db;"></i>
            <div style="font-size: 1.1em; margin-bottom: 8px; color: #374151;">Ch∆∞a c√≥ g√≥p √Ω n√†o</div>
            <small style="color: #9ca3af;">G√≥p √Ω s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y theo th·ªùi gian th·ª±c</small>
          </div>
        `;
        return;
      }
      
      console.log('üìù Displaying feedbacks:', feedbacks.length, 'items');
      
      // Sort feedbacks ƒë·ªÉ ƒë·∫£m b·∫£o m·ªõi nh·∫•t ·ªü tr√™n c√πng
      const sortedFeedbacks = [...feedbacks].sort((a, b) => {
        const dateA = a.createdAt || parseFeedbackTimestamp(a.timestamp);
        const dateB = b.createdAt || parseFeedbackTimestamp(b.timestamp);
        return dateB - dateA; // Newest first
      });
      
      console.log('üîÑ Sorted feedbacks order:', sortedFeedbacks.map(f => f.timestamp));
      
      // Generate YouTube Live Chat style feedback items HTML
      let feedbackHTML = '';
      sortedFeedbacks.forEach((feedback, index) => {
        const isAnonymous = feedback.isAnonymous || !feedback.phone || feedback.phone === 'anonymous';
        const roomDisplay = isAnonymous ? '·∫®n danh' : `Ph√≤ng ${feedback.roomNumber}`;
        const avatarClass = isAnonymous ? 'anonymous' : 'named';
        const usernameClass = isAnonymous ? 'anonymous' : 'named';
        
        // Create avatar icon (room icon or anonymous icon)  
        const avatarIcon = isAnonymous ? '<i class="fas fa-user-secret"></i>' : '<i class="fas fa-door-open"></i>';
        
        // Use timestamp as ID if id is not available
        const feedbackId = feedback.id || feedback.timestamp || 'unknown';
        
        // Add animation delay for newer items (first few items)
        const animationDelay = index < 3 ? `style="animation-delay: ${index * 0.1}s"` : '';
        
        // Get both relative and absolute time
        const relativeTime = getRelativeTime(feedback.timestamp);
        const absoluteTime = formatFeedbackTime(feedback.timestamp);
        
        feedbackHTML += `
          <div class="feedback-item" data-id="${feedbackId}" ${animationDelay}>
            <div class="feedback-avatar ${avatarClass}">
              ${avatarIcon}
            </div>
            <div class="feedback-content-wrapper">
              <div class="feedback-message-content">
                <span class="feedback-username ${usernameClass}">${roomDisplay}:</span>
                <span class="feedback-message">${escapeHtml(feedback.content)}</span>
              </div>
              <span class="feedback-time" title="${absoluteTime}">${relativeTime}</span>
            </div>
          </div>
        `;
      });
      
      // Clear old content and add new content
      feedbackList.innerHTML = feedbackHTML;
      
      // Force scroll to top ƒë·ªÉ hi·ªÉn th·ªã feedback m·ªõi nh·∫•t
      feedbackList.scrollTop = 0;
      
      console.log('‚úÖ Feedbacks displayed, scroll reset to top');
    }
    

    

    
    // Cleanup feedback listener
    function cleanupFeedbackListener() {
      if (feedbackListener && feedbackRef) {
        console.log('üßπ Cleaning up feedback listener...');
        feedbackRef.off('value', feedbackListener);
        feedbackListener = null;
      }
    }
    
    
    

    

    
    // Get relative time (2 ph√∫t tr∆∞·ªõc, 1 gi·ªù tr∆∞·ªõc, etc.)
    function getRelativeTime(timestamp) {
      try {
        const now = new Date();
        const past = parseFeedbackTimestamp(timestamp);
        const diffMs = now - past;
        
        if (diffMs < 0) return "v·ª´a xong"; // Future timestamp
        
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        const diffWeeks = Math.floor(diffDays / 7);
        const diffMonths = Math.floor(diffDays / 30);
        
        if (diffSeconds < 60) return "v·ª´a xong";
        if (diffMinutes < 60) return `${diffMinutes} ph√∫t tr∆∞·ªõc`;
        if (diffHours < 24) return `${diffHours} gi·ªù tr∆∞·ªõc`;
        if (diffDays < 7) return `${diffDays} ng√†y tr∆∞·ªõc`;
        if (diffWeeks < 4) return `${diffWeeks} tu·∫ßn tr∆∞·ªõc`;
        return `${diffMonths} th√°ng tr∆∞·ªõc`;
        
      } catch (error) {
        console.error('‚ùå Relative time error:', error);
        return "kh√¥ng x√°c ƒë·ªãnh";
      }
    }

    // Format feedback timestamp for display - v4.0 (for hover tooltip)
    function formatFeedbackTime(timestamp) {
      try {
        // Handle Firebase format: YYYY-MM-DD_HH-MM-SS (underscore between date and time)
        if (timestamp && typeof timestamp === 'string') {
          // Replace underscore with hyphen to make consistent: YYYY-MM-DD-HH-MM-SS
          const normalizedTimestamp = timestamp.replace('_', '-');
          
          if (normalizedTimestamp.includes('-') && normalizedTimestamp.length >= 19) {
            const parts = normalizedTimestamp.split('-');
            if (parts.length >= 6) {
              const year = parts[0].substring(2); // L·∫•y 2 ch·ªØ s·ªë cu·ªëi c·ªßa nƒÉm
              const month = parts[1];
              const day = parts[2];
              const hour = parts[3];
              const minute = parts[4];
              
              return `v√†o l√∫c ${hour}:${minute} ng√†y ${day}/${month}/${year}`;
            }
          }
        }
        
        // Fallback to date parsing
        const date = new Date(timestamp);
        if (!isNaN(date.getTime())) {
          const day = date.getDate().toString().padStart(2, '0');
          const month = (date.getMonth() + 1).toString().padStart(2, '0');
          const year = date.getFullYear().toString().substring(2);
          const hour = date.getHours().toString().padStart(2, '0');
          const minute = date.getMinutes().toString().padStart(2, '0');
          
          return `v√†o l√∫c ${hour}:${minute} ng√†y ${day}/${month}/${year}`;
        }
        
        // Last fallback
        return timestamp;
      } catch (error) {
        console.error('‚ùå Format time error:', error);
        return timestamp;
      }
    }
    
    // Escape HTML to prevent XSS
    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }
    
    // Cleanup feedback listener
    function cleanupFeedbackListener() {
      if (feedbackRef && feedbackListener) {
        console.log('üßπ Cleaning up feedback listener...');
        feedbackRef.off('value', feedbackListener);
        feedbackListener = null;
      }
    }
    

    

    
    // Load monthly statistics on page load - MOVED TO MAIN DOMContentLoaded
    /*
    document.addEventListener('DOMContentLoaded', function() {
      // Auto-load monthly statistics immediately
      refreshMonthlyStats();
    });
    */
    
