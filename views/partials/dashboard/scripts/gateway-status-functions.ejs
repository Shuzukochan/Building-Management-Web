<script>
// ==================== GATEWAY STATUS FUNCTIONS ====================

// Global variables
let gatewayStatusCheckInterval = null;
let lastGatewayStatus = null; // Track ƒë·ªÉ ch·ªâ log khi thay ƒë·ªïi
const GATEWAY_TIMEOUT_SECONDS = 30; // C·ª©ng 30 gi√¢y nh∆∞ y√™u c·∫ßu

/**
 * G·ªçi API ƒë·ªÉ l·∫•y tr·∫°ng th√°i gateway
 * @returns {Promise<Object>} Gateway data ho·∫∑c null n·∫øu l·ªói
 */
async function fetchGatewayStatus() {
    try {
        // console.log('üì° Calling gateway status API...');
        
        const response = await fetch('/api/gateway-status', {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
        });

        // console.log(`üì° API Response status: ${response.status}`);

        if (!response.ok) {
            const errorText = await response.text();
            console.error(`‚ùå API Error: ${response.status} - ${errorText}`);
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        // console.log('üì° Raw API response:', data);
        
        if (!data.success) {
            console.error('‚ùå API returned success: false', data);
            throw new Error(data.error || 'API tr·∫£ v·ªÅ kh√¥ng th√†nh c√¥ng');
        }
        
        // console.log('üì° Gateway data:', data.gateway);
        return data.gateway || null;
    } catch (error) {
        console.error('‚ùå L·ªói khi g·ªçi API tr·∫°ng th√°i gateway:', error);
        return null;
    }
}

/**
 * Ki·ªÉm tra tr·∫°ng th√°i gateway d·ª±a tr√™n lastSeenAt v·ªõi timeout c·ª©ng 30 gi√¢y
 * @param {string} lastSeenAt - Th·ªùi gian cu·ªëi c√πng gateway ƒë∆∞·ª£c th·∫•y (ISO string)
 * @returns {string} 'online' ho·∫∑c 'offline'
 */
function getGatewayStatus(lastSeenAt) {
    if (!lastSeenAt) return 'offline';
    
    const lastSeen = new Date(lastSeenAt);
    const now = new Date();
    const diffInSeconds = (now - lastSeen) / 1000;
    
    // C·ª©ng 30 gi√¢y: n·∫øu > 30 gi√¢y th√¨ offline
    return diffInSeconds <= GATEWAY_TIMEOUT_SECONDS ? 'online' : 'offline';
}

/**
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa gateway indicator
 * @param {string} gatewayId - Gateway ID
 * @param {string} status - Tr·∫°ng th√°i: 'online' ho·∫∑c 'offline'
 */
function updateGatewayStatusIndicator(gatewayId, status) {
    const indicators = document.querySelectorAll(`[data-gateway-id="${gatewayId}"]`);
    
    // ƒê·ªãnh nghƒ©a m√†u s·∫Øc v√† title cho t·ª´ng tr·∫°ng th√°i
    const statusConfig = {
        'online': {
            color: '#10b981', // xanh l√°
            title: 'Gateway ƒëang ho·∫°t ƒë·ªông'
        },
        'offline': {
            color: '#ef4444', // ƒë·ªè  
            title: 'Gateway m·∫•t k·∫øt n·ªëi'
        }
    };
    
    const config = statusConfig[status] || statusConfig['offline'];
    
    indicators.forEach(indicator => {
        // Set inline style cho gateway status indicator - gi·ªëng h·ªát node
        indicator.style.cssText = `
            display: inline-block !important;
            width: 8px !important;
            height: 8px !important;
            border-radius: 50% !important;
            position: absolute !important;
            left: -20px !important;
            top: 50% !important;
            margin-top: -4px !important;
            transition: none !important;
            animation: none !important;
            transform: none !important;
            box-shadow: none !important;
            border: none !important;
            outline: none !important;
            background-color: ${config.color} !important;
        `;
        
        // X√≥a t·∫•t c·∫£ class ƒë·ªÉ tr√°nh CSS conflict
        indicator.className = 'gateway-status-indicator';
        
        // Set title
        indicator.title = config.title;
    });
}

/**
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i gateway status indicator
 */
async function updateAllGatewayStatusIndicators() {
    const gatewayData = await fetchGatewayStatus();
    
    if (!gatewayData) {
        // Set t·∫•t c·∫£ gateway indicators th√†nh offline
        const allIndicators = document.querySelectorAll('.gateway-status-indicator[data-gateway-id]');
        allIndicators.forEach(indicator => {
            const gatewayId = indicator.getAttribute('data-gateway-id');
            updateGatewayStatusIndicator(gatewayId, 'offline');
        });
        return;
    }

    // Ki·ªÉm tra tr·∫°ng th√°i gateway
    const gatewayStatus = getGatewayStatus(gatewayData.lastSeenAt);

    // C·∫≠p nh·∫≠t t·∫•t c·∫£ indicators
    const allIndicators = document.querySelectorAll('.gateway-status-indicator[data-gateway-id]');
    
    allIndicators.forEach(indicator => {
        const gatewayId = indicator.getAttribute('data-gateway-id');
        updateGatewayStatusIndicator(gatewayId, gatewayStatus);
    });

    // Log ch·ªâ khi status thay ƒë·ªïi
    if (lastGatewayStatus !== gatewayStatus) {
        console.log(`üåê Gateway: ${gatewayStatus}`);
        lastGatewayStatus = gatewayStatus;
    }
}

/**
 * Kh·ªüi t·∫°o gateway status indicators v·ªõi tr·∫°ng th√°i loading
 */
function initializeGatewayStatusIndicators() {
    const allIndicators = document.querySelectorAll('.gateway-status-indicator[data-gateway-id]');
    
    allIndicators.forEach(indicator => {
        // Set inline style loading state - gi·ªëng h·ªát node
        indicator.style.cssText = `
            display: inline-block !important;
            width: 8px !important;
            height: 8px !important;
            border-radius: 50% !important;
            position: absolute !important;
            left: -20px !important;
            top: 50% !important;
            margin-top: -4px !important;
            transition: none !important;
            animation: none !important;
            transform: none !important;
            box-shadow: none !important;
            border: none !important;
            outline: none !important;
            background-color: #6b7280 !important;
        `;
        
        // Reset class
        indicator.className = 'gateway-status-indicator';
        indicator.title = 'ƒêang ki·ªÉm tra tr·∫°ng th√°i gateway...';
    });
}

/**
 * B·∫Øt ƒë·∫ßu ki·ªÉm tra tr·∫°ng th√°i gateway ƒë·ªãnh k·ª≥
 */
async function startGatewayStatusCheck() {
    // D·ª´ng interval c≈© n·∫øu c√≥
    if (gatewayStatusCheckInterval) {
        clearInterval(gatewayStatusCheckInterval);
    }

    // Kh·ªüi t·∫°o indicators
    initializeGatewayStatusIndicators();

    // Ki·ªÉm tra ngay l·∫≠p t·ª©c
    updateAllGatewayStatusIndicators();

    // Thi·∫øt l·∫≠p ki·ªÉm tra ƒë·ªãnh k·ª≥ m·ªói 60 gi√¢y
    gatewayStatusCheckInterval = setInterval(() => {
        updateAllGatewayStatusIndicators();
    }, 30000);
}

/**
 * D·ª´ng ki·ªÉm tra tr·∫°ng th√°i gateway ƒë·ªãnh k·ª≥
 */
function stopGatewayStatusCheck() {
    if (gatewayStatusCheckInterval) {
        clearInterval(gatewayStatusCheckInterval);
        gatewayStatusCheckInterval = null;
    }
}

// Kh·ªüi t·∫°o khi DOM loaded
document.addEventListener('DOMContentLoaded', () => {
    // Delay ng·∫Øn ƒë·ªÉ ƒë·∫£m b·∫£o c√°c th√†nh ph·∫ßn kh√°c ƒë√£ load xong
    setTimeout(() => {
        // Ch·ªâ kh·ªüi t·∫°o n·∫øu c√≥ gateway status indicators
        const gatewayIndicators = document.querySelectorAll('.gateway-status-indicator[data-gateway-id]');
        
        if (gatewayIndicators.length > 0) {
            startGatewayStatusCheck();
        }
    }, 500);
});

// D·ªçn d·∫πp khi trang ƒë∆∞·ª£c unload
window.addEventListener('beforeunload', () => {
    stopGatewayStatusCheck();
});

</script> 