<script>
// ==================== NODE STATUS FUNCTIONS ====================

// Global variables
let nodeStatusCheckInterval = null;
let deviceTimeoutSeconds = 14400; // default, will be loaded from Firebase

/**
 * L·∫•y c·∫•u h√¨nh timeout t·ª´ Firebase theo building ID
 * @returns {Promise<number>} Timeout trong gi√¢y
 */
async function fetchDeviceTimeout() {
    try {
        const response = await fetch('/api/device-timeout', {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        
        if (!data.success) {
            throw new Error(data.error || 'API tr·∫£ v·ªÅ kh√¥ng th√†nh c√¥ng');
        }
        
        return data.deviceTimeout || 60;
    } catch (error) {
        console.error('L·ªói khi l·∫•y device timeout:', error);
        return 60; // fallback to default
    }
}

/**
 * G·ªçi API proxy n·ªôi b·ªô ƒë·ªÉ l·∫•y tr·∫°ng th√°i t·∫•t c·∫£ thi·∫øt b·ªã
 * @returns {Promise<Array>} Danh s√°ch thi·∫øt b·ªã ho·∫∑c null n·∫øu l·ªói
 */
async function fetchDeviceStatus() {
    try {
        const response = await fetch('/api/device-status', {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        
        if (!data.success) {
            throw new Error(data.error || 'API tr·∫£ v·ªÅ kh√¥ng th√†nh c√¥ng');
        }
        
        return data.result || [];
    } catch (error) {
        console.error('L·ªói khi g·ªçi API tr·∫°ng th√°i thi·∫øt b·ªã:', error);
        return null;
    }
}

/**
 * Ki·ªÉm tra tr·∫°ng th√°i thi·∫øt b·ªã d·ª±a tr√™n lastSeenAt
 * @param {string} lastSeenAt - Th·ªùi gian cu·ªëi c√πng thi·∫øt b·ªã ƒë∆∞·ª£c th·∫•y (ISO string)
 * @returns {string} 'online', 'warning', ho·∫∑c 'offline'
 */
function getDeviceStatus(lastSeenAt) {
    if (!lastSeenAt) return 'offline';
    
    const lastSeen = new Date(lastSeenAt);
    const now = new Date();
    const diffInSeconds = (now - lastSeen) / 1000;
    
    const warningThreshold = deviceTimeoutSeconds * 1.5; // x1.5 = warning
    const offlineThreshold = deviceTimeoutSeconds * 2;   // x2 = offline
    
    if (diffInSeconds <= deviceTimeoutSeconds) {
        return 'online';
    } else if (diffInSeconds <= warningThreshold) {
        return 'warning';
    } else {
        return 'offline';
    }
}

/**
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa m·ªôt node indicator
 * @param {string} devEui - Device EUI c·ªßa node
 * @param {string} status - Tr·∫°ng th√°i: 'online', 'warning', 'offline'
 */
function updateNodeStatusIndicator(devEui, status) {
    const indicators = document.querySelectorAll(`[data-node-dev-eui="${devEui}"]`);
    
    // ƒê·ªãnh nghƒ©a m√†u s·∫Øc v√† title cho t·ª´ng tr·∫°ng th√°i
    const statusConfig = {
        'online': {
            color: '#10b981', // xanh l√°
            title: 'Thi·∫øt b·ªã ƒëang ho·∫°t ƒë·ªông'
        },
        'warning': {
            color: '#f59e0b', // v√†ng/cam
            title: 'Thi·∫øt b·ªã ph·∫£n h·ªìi ch·∫≠m - c·∫£nh b√°o'
        },
        'offline': {
            color: '#ef4444', // ƒë·ªè
            title: 'Thi·∫øt b·ªã m·∫•t k·∫øt n·ªëi'
        }
    };
    
    const config = statusConfig[status] || statusConfig['offline'];
    
    indicators.forEach(indicator => {
        // BYPASS CSS HO√ÄN TO√ÄN - d√πng inline style
        indicator.style.cssText = `
            display: inline-block !important;
            width: 8px !important;
            height: 8px !important;
            border-radius: 50% !important;
            position: absolute !important;
            right: -20px !important;
            top: 50% !important;
            margin-top: -4px !important;
            transition: none !important;
            animation: none !important;
            transform: none !important;
            box-shadow: none !important;
            border: none !important;
            outline: none !important;
            background-color: ${config.color} !important;
        `;
        
        // X√≥a t·∫•t c·∫£ class ƒë·ªÉ tr√°nh CSS conflict
        indicator.className = 'node-status-indicator';
        
        // Set title
        indicator.title = config.title;
    });
}

/**
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i t·∫•t c·∫£ node status indicators
 */
async function updateAllNodeStatusIndicators() {
    const deviceList = await fetchDeviceStatus();
    
    if (!deviceList) {
        console.warn('Kh√¥ng th·ªÉ l·∫•y tr·∫°ng th√°i thi·∫øt b·ªã, s·∫Ω th·ª≠ l·∫°i sau.');
        return;
    }

    // T·∫°o map devEui -> tr·∫°ng th√°i
    const deviceStatusMap = {};
    deviceList.forEach(device => {
        if (device.devEui && device.lastSeenAt) {
            deviceStatusMap[device.devEui] = getDeviceStatus(device.lastSeenAt);
        }
    });

    // C·∫≠p nh·∫≠t t·∫•t c·∫£ indicators
    const allIndicators = document.querySelectorAll('.node-status-indicator[data-node-dev-eui]');
    
    allIndicators.forEach(indicator => {
        const devEui = indicator.getAttribute('data-node-dev-eui');
        if (devEui && deviceStatusMap.hasOwnProperty(devEui)) {
            updateNodeStatusIndicator(devEui, deviceStatusMap[devEui]);
        } else {
            // Thi·∫øt b·ªã kh√¥ng t√¨m th·∫•y trong API response -> offline
            updateNodeStatusIndicator(devEui, 'offline');
        }
    });

    console.log(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i cho ${allIndicators.length} node(s) - Timeout: ${deviceTimeoutSeconds}s`);
}

/**
 * Kh·ªüi t·∫°o node status indicators v·ªõi tr·∫°ng th√°i loading
 */
function initializeNodeStatusIndicators() {
    const allIndicators = document.querySelectorAll('.node-status-indicator[data-node-dev-eui]');
    
    allIndicators.forEach(indicator => {
        // BYPASS CSS HO√ÄN TO√ÄN - set inline style ngay t·ª´ ƒë·∫ßu
        indicator.style.cssText = `
            display: inline-block !important;
            width: 8px !important;
            height: 8px !important;
            border-radius: 50% !important;
            position: absolute !important;
            right: -20px !important;
            top: 50% !important;
            margin-top: -4px !important;
            transition: none !important;
            animation: none !important;
            transform: none !important;
            box-shadow: none !important;
            border: none !important;
            outline: none !important;
            background-color: #6b7280 !important;
        `;
        
        // Reset class
        indicator.className = 'node-status-indicator';
        indicator.title = 'ƒêang ki·ªÉm tra tr·∫°ng th√°i...';
    });

    console.log(`üîÑ Kh·ªüi t·∫°o ${allIndicators.length} node status indicator(s)`);
}

/**
 * B·∫Øt ƒë·∫ßu ki·ªÉm tra tr·∫°ng th√°i node ƒë·ªãnh k·ª≥
 */
async function startNodeStatusCheck() {
    // D·ª´ng interval c≈© n·∫øu c√≥
    if (nodeStatusCheckInterval) {
        clearInterval(nodeStatusCheckInterval);
    }

    // L·∫•y timeout t·ª´ Firebase tr∆∞·ªõc
    deviceTimeoutSeconds = await fetchDeviceTimeout();
    console.log(`üîß Device timeout ƒë∆∞·ª£c thi·∫øt l·∫≠p: ${deviceTimeoutSeconds}s (Warning: ${deviceTimeoutSeconds * 1.5}s, Offline: ${deviceTimeoutSeconds * 2}s)`);

    // Kh·ªüi t·∫°o indicators
    initializeNodeStatusIndicators();

    // Ki·ªÉm tra ngay l·∫≠p t·ª©c
    updateAllNodeStatusIndicators();

    // Thi·∫øt l·∫≠p ki·ªÉm tra ƒë·ªãnh k·ª≥ m·ªói 1 ph√∫t (60000 ms)
    nodeStatusCheckInterval = setInterval(() => {
        updateAllNodeStatusIndicators();
    }, 10000);
}

/**
 * D·ª´ng ki·ªÉm tra tr·∫°ng th√°i node ƒë·ªãnh k·ª≥
 */
function stopNodeStatusCheck() {
    if (nodeStatusCheckInterval) {
        clearInterval(nodeStatusCheckInterval);
        nodeStatusCheckInterval = null;
        console.log('‚èπÔ∏è ƒê√£ d·ª´ng ki·ªÉm tra tr·∫°ng th√°i node ƒë·ªãnh k·ª≥');
    }
}

// Kh·ªüi t·∫°o khi DOM loaded
document.addEventListener('DOMContentLoaded', () => {
    // Delay m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o c√°c th√†nh ph·∫ßn kh√°c ƒë√£ load xong
    setTimeout(() => {
        startNodeStatusCheck();
    }, 1000);
});

// D·ªçn d·∫πp khi trang ƒë∆∞·ª£c unload
window.addEventListener('beforeunload', () => {
    stopNodeStatusCheck();
});
</script> 